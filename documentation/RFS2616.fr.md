# RFC 2616 â€” Section 1 : Introduction

## Objectif du protocole HTTP/1.1

HTTP (HyperText Transfer Protocol) est un **protocole d'application** conÃ§u pour permettre la communication entre des **systÃ¨mes distribuÃ©s, collaboratifs et hypermÃ©dia**.

Il sâ€™agit dâ€™un protocole :
- **OrientÃ© requÃªte/rÃ©ponse**, principalement entre un **client** (ex. navigateur) et un **serveur**.
- **Sans Ã©tat** (*stateless*) : chaque requÃªte est **indÃ©pendante** des prÃ©cÃ©dentes ; le serveur ne conserve pas de contexte entre deux requÃªtes.
- **Extensible**, conÃ§u pour supporter de **nouvelles mÃ©thodes**, **en-tÃªtes**, ou **types de mÃ©dias**.
- **GÃ©nÃ©rique**, pouvant servir Ã  transfÃ©rer **toute forme de donnÃ©es** (pas seulement du HTML).
- **Transport-indÃ©pendant** : mÃªme si HTTP fonctionne le plus souvent au-dessus de TCP, il pourrait Ãªtre utilisÃ© avec d'autres protocoles fiables.

## Contexte historique

- HTTP a Ã©tÃ© initialement conÃ§u pour le projet **World Wide Web**.
- HTTP/1.0 (dÃ©crit dans le RFC 1945) a introduit la structure de base du protocole.
- HTTP/1.1 (ce RFC) **Ã©tend et amÃ©liore** HTTP/1.0, notamment avec :
  - **Connexions persistantes** (rÃ©utilisation de la connexion TCP)
  - **ContrÃ´le de cache plus robuste**
  - **Support explicite des hÃ´tes virtuels** (via l'en-tÃªte `Host`)
  - **Gestion fine des erreurs** et du **contenu nÃ©gociÃ©**

## DÃ©ploiement

- HTTP/1.1 a Ã©tÃ© conÃ§u pour **remplacer progressivement HTTP/1.0**.
- Il est **rÃ©trocompatible** avec HTTP/1.0 Ã  certains Ã©gards, mais des modifications ont Ã©tÃ© apportÃ©es pour clarifier et amÃ©liorer la norme.

## InteropÃ©rabilitÃ©

- HTTP/1.1 vise Ã  **favoriser lâ€™interopÃ©rabilitÃ©** entre divers logiciels et plateformes.
- Il impose des **contraintes plus strictes** sur les implÃ©mentations pour Ã©viter les interprÃ©tations ambigÃ¼es du protocole.
- Le protocole repose sur une syntaxe **claire, standardisÃ©e, extensible** (utilisant une grammaire formelle dÃ©crite dans la section 2).

## Structure du document

Ce document (RFC 2616) est une **spÃ©cification complÃ¨te** du protocole HTTP/1.1. Il couvre :
- Les **messages** (requÃªtes et rÃ©ponses)
- La **sÃ©mantique** des mÃ©thodes HTTP
- Les **codes de statut**
- Les **en-tÃªtes**
- La **gestion du cache**, des **connexions**, de **lâ€™authentification**, et de la **sÃ©curitÃ©**

> ğŸ’¡ Remarque : HTTP/1.1 est un protocole **de plus haut niveau** que TCP. Il sâ€™appuie sur des services de transport fiables (comme TCP) mais ne traite pas directement des paquets rÃ©seau.

---

# RFC 2616 â€” Section 2 : Conventions de Notation et Grammaire GÃ©nÃ©rique

## 2.1 â€” Mots-clÃ©s normatifs

Le document utilise les mots-clÃ©s suivants, conformÃ©ment au RFC 2119, pour indiquer le niveau dâ€™exigence dâ€™une rÃ¨gle :

- **MUST** / **REQUIRED** : la rÃ¨gle est obligatoire.
    
- **MUST NOT** : la rÃ¨gle est strictement interdite.
    
- **SHOULD** : il est fortement recommandÃ© de suivre la rÃ¨gle, sauf exception justifiÃ©e.
    
- **SHOULD NOT** : il est dÃ©conseillÃ© de suivre la rÃ¨gle, sauf cas exceptionnel.
    
- **MAY** : la rÃ¨gle est optionnelle.
    

Ces mots-clÃ©s sont utilisÃ©s dans tout le document pour indiquer ce qui est obligatoire, recommandÃ© ou facultatif.

## 2.2 â€” Grammaire gÃ©nÃ©rique (Augmented BNF)

La syntaxe utilisÃ©e est appelÃ©e **ABNF** (Augmented Backus-Naur Form), dÃ©rivÃ©e du RFC 822.

Elle permet de dÃ©crire la structure formelle des Ã©lÃ©ments HTTP : lignes de requÃªte, en-tÃªtes, corps de message, etc.

## 2.3 â€” Symboles utilisÃ©s dans la grammaire

- `"` : chaÃ®ne littÃ©rale (exemple : `"GET"`)
    
- `|` : opÃ©rateur "ou" logique (exemple : `GET | POST`)
    
- `*` : 0 ou plusieurs rÃ©pÃ©titions
    
- `+` : 1 ou plusieurs rÃ©pÃ©titions
    
- `?` : 0 ou 1 rÃ©pÃ©tition
    
- `()` : regroupe plusieurs Ã©lÃ©ments
    
- `=` ou `::=` : dÃ©finition dâ€™une rÃ¨gle
    

**Exemple de rÃ¨gle :**

method = "GET" | "POST" | "PUT" | "DELETE"

## 2.4 â€” Jeu de caractÃ¨res

- Les mots-clÃ©s et en-tÃªtes sont en **US-ASCII** (7 bits).
    
- Les noms dâ€™en-tÃªte ne sont **pas sensibles Ã  la casse**.
    
- Le corps du message peut contenir des donnÃ©es binaires, mais les mÃ©tadonnÃ©es restent en ASCII.
    

## 2.5 â€” LinÃ©arisation (folding)

- Certains champs dâ€™en-tÃªte peuvent Ãªtre Ã©crits sur plusieurs lignes.
    
- Les lignes supplÃ©mentaires doivent **commencer par un espace ou une tabulation**.
    
- Ce comportement (appelÃ© "folding") est **obsolÃ¨te**, mais mentionnÃ© pour compatibilitÃ©.
    

**Exemple :**

Content-Type: text/html;  
charset=UTF-8

## 2.6 â€” Ã‰lÃ©ments lexicaux fondamentaux

- **token** : suite de caractÃ¨res alphanumÃ©riques autorisÃ©s (pas d'espaces, ni de sÃ©parateurs spÃ©ciaux).
    
- **separators** : ensemble de caractÃ¨res interdits dans un token :  
    `()<>@,;:\"/[]?={} \t`
    
- **quoted-string** : chaÃ®ne entre guillemets, pouvant contenir des caractÃ¨res Ã©chappÃ©s avec `\`.
    

**Exemple de rÃ¨gle :**

token = 1*<tout caractÃ¨re sauf sÃ©parateurs et caractÃ¨res de contrÃ´le>

## 2.7 â€” UtilitÃ© pour les implÃ©mentations

- La grammaire permet dâ€™Ã©viter les **ambiguÃ¯tÃ©s** dans les implÃ©mentations de clients et serveurs HTTP.
    
- Elle est utilisÃ©e dans toutes les autres sections du RFC pour **formuler prÃ©cisÃ©ment les rÃ¨gles syntaxiques**.
    
---

# RFC 2616 â€” Section 3 : ParamÃ¨tres du Protocole

## 3.1 â€” Version du protocole HTTP

La version du protocole est indiquÃ©e dans chaque message HTTP selon la forme suivante :

HTTP-Version = "HTTP" "/" chiffre "." chiffre

Exemples :

- HTTP/1.0
    
- HTTP/1.1
    

Le client annonce cette version dans la ligne de requÃªte. Le serveur rÃ©pond gÃ©nÃ©ralement avec la mÃªme version, ou celle quâ€™il prend en charge.

**Remarque** : Un serveur **ne doit pas** renvoyer une version plus rÃ©cente que celle quâ€™il comprend rÃ©ellement.

---

## 3.2 â€” Identificateurs de ressource (URI)

Les ressources HTTP sont identifiÃ©es par des **URI** (Uniform Resource Identifiers). Ces URI peuvent prendre plusieurs formes selon leur contexte :

- **Request-URI** : URI dans la ligne de requÃªte
    
- **absoluteURI** : commence par le schÃ©ma (ex : `http://example.com/index.html`)
    
- **relativeURI** : relatif au contexte (ex : `/index.html`)
    
- **en-tÃªte Host** : obligatoire en HTTP/1.1 pour dÃ©signer le nom de domaine (utilisÃ© pour lâ€™hÃ©bergement virtuel)
    

**Exemple** :  
GET /index.html HTTP/1.1  
Host: [www.example.com](http://www.example.com/)

---

## 3.3 â€” Dates et heures

Les dates HTTP doivent Ãªtre exprimÃ©es en format **RFC 1123**, en anglais, Ã  lâ€™heure **GMT**.

Format normalisÃ© :  
Sun, 06 Nov 1994 08:49:37 GMT

Autres formats acceptÃ©s (pour compatibilitÃ© descendante) :

- RFC 850 : Sunday, 06-Nov-94 08:49:37 GMT
    
- asctime() : Sun Nov 6 08:49:37 1994
    

**Important** : HTTP/1.1 exige que **les serveurs utilisent uniquement le format RFC 1123 dans leurs rÃ©ponses**.

Les dates sont utilisÃ©es notamment dans les en-tÃªtes :

- `Date`
    
- `Expires`
    
- `Last-Modified`
    
- `If-Modified-Since`
    

---

## 3.4 â€” Types de mÃ©dia (Media Types)

Le contenu dâ€™un message HTTP est dÃ©crit par son **type MIME**.

Syntaxe :  
media-type = type "/" subtype *( ";" parameter )

Exemples :

- text/html
    
- text/plain; charset=UTF-8
    
- application/json
    
- image/png
    

Le paramÃ¨tre `charset` est couramment utilisÃ© pour les types `text/*`.

---

## 3.5 â€” Langues naturelles

Le client peut indiquer ses prÃ©fÃ©rences linguistiques avec lâ€™en-tÃªte `Accept-Language`.

Exemples de codes de langue :

- fr
    
- en
    
- en-US
    
- fr-CA
    

Cela permet au serveur de choisir la **version localisÃ©e** la plus adaptÃ©e du contenu (voir nÃ©gociation de contenu).

---

## 3.6 â€” Encodage de transfert (Transfer-Encoding)

Cet encodage dÃ©crit **comment le contenu est envoyÃ©**, indÃ©pendamment de son format initial.

Encodages possibles :

- chunked (par blocs) â€” utilisÃ© lorsque la taille nâ€™est pas connue Ã  lâ€™avance
    
- gzip, compress â€” pour la compression des donnÃ©es
    

**chunked** est obligatoire dans certains cas, notamment pour les rÃ©ponses gÃ©nÃ©rÃ©es dynamiquement.

---

## 3.7 â€” Encodage de contenu (Content-Encoding)

Le champ `Content-Encoding` indique une **transformation appliquÃ©e au contenu original**, que le client devra **inverser** pour lire la ressource.

Exemples :

- gzip
    
- deflate
    
- compress
    

Cela permet la compression de fichiers avant envoi, sans changer le type MIME dÃ©clarÃ©.

---

## 3.8 â€” Codage des caractÃ¨res (Charset)

Les contenus textuels peuvent indiquer le jeu de caractÃ¨res utilisÃ© grÃ¢ce au paramÃ¨tre `charset` dans lâ€™en-tÃªte `Content-Type`.

Exemples :

- ISO-8859-1 (valeur par dÃ©faut si non prÃ©cisÃ©)
    
- UTF-8
    
- US-ASCII
    

Exemple dâ€™en-tÃªte :  
Content-Type: text/html; charset=UTF-8

---

## 3.9 â€” QualitÃ© de prÃ©fÃ©rence (poids)

Certaines valeurs utilisent un **coefficient de qualitÃ©** (`q`) pour exprimer une prÃ©fÃ©rence relative (entre 0 et 1).

Exemple :  
Accept-Language: fr, en;q=0.8, de;q=0.5

Signifie : prÃ©fÃ©rence pour le franÃ§ais, ensuite lâ€™anglais, puis lâ€™allemand.

---

# RFC 2616 â€” Section 4 : HTTP Message

## Structure gÃ©nÃ©rale

HTTP est basÃ© sur un modÃ¨le **requÃªte/rÃ©ponse** entre un client et un serveur.

Chaque message HTTP (quâ€™il sâ€™agisse dâ€™une requÃªte ou dâ€™une rÃ©ponse) est composÃ© de trois parties :

1. **Start-Line** : ligne de requÃªte (pour un client) ou ligne de statut (pour un serveur)
    
2. **Header Fields** : ensemble de champs dâ€™en-tÃªte dÃ©crivant la requÃªte ou la rÃ©ponse
    
3. **Message Body** (facultatif) : contient les donnÃ©es associÃ©es (ex. : contenu HTML, image, JSONâ€¦)
    

## 4.1 â€” Message Format

La structure complÃ¨te dâ€™un message est la suivante :

- Une ligne de dÃ©part (Request-Line ou Status-Line)
    
- ZÃ©ro ou plusieurs lignes dâ€™en-tÃªte (Header Fields)
    
- Une ligne vide (sÃ©parateur entre les en-tÃªtes et le corps)
    
- Un corps de message facultatif
    

**Exemple simplifiÃ© de requÃªte HTTP :**

GET /index.html HTTP/1.1  
Host: [www.example.com](http://www.example.com/)  
Accept: text/html

[ligne vide]  
[corps du message, sâ€™il y en a un]

## 4.2 â€” Ligne de dÃ©part (Start-Line)

La ligne de dÃ©part est :

- Une **Request-Line** pour une requÃªte :
    
    - format : `Method SP Request-URI SP HTTP-Version CRLF`
        
    - exemple : `GET /page.html HTTP/1.1`
        
- Une **Status-Line** pour une rÃ©ponse :
    
    - format : `HTTP-Version SP Status-Code SP Reason-Phrase CRLF`
        
    - exemple : `HTTP/1.1 200 OK`
        

## 4.3 â€” En-tÃªtes HTTP (Header Fields)

Les en-tÃªtes sont une collection de paires nom/valeur, suivies de `CRLF` (retour chariot + saut de ligne).

Chaque en-tÃªte a cette forme :

Nom: valeur

Exemple :  
Content-Type: text/html  
Content-Length: 342

Les en-tÃªtes permettent de :

- dÃ©crire les capacitÃ©s du client (`Accept`, `User-Agent`)
    
- donner des informations sur la ressource (`Content-Type`, `Last-Modified`)
    
- gÃ©rer la communication (`Connection`, `Host`, `Transfer-Encoding`)
    

## 4.4 â€” Corps du message (Message Body)

Le corps contient les **donnÃ©es effectives** transfÃ©rÃ©es.

Il est facultatif :

- PrÃ©sent dans les rÃ©ponses Ã  une requÃªte `GET`, `POST`, etc.
    
- Peut Ãªtre vide dans les rÃ©ponses avec code `204 No Content`, `304 Not Modified` ou dans les requÃªtes `HEAD`.
    

Le corps peut Ãªtre :

- **binaire** ou **texte**
    
- encodÃ© (`gzip`, `chunked`, etc.)
    
- de taille connue (`Content-Length`) ou inconnue (avec `Transfer-Encoding: chunked`)
    

## 4.5 â€” DÃ©tection de la longueur du corps

Le client doit dÃ©terminer la longueur du corps Ã  lâ€™aide des en-tÃªtes suivants :

- **Content-Length** : indique la taille exacte du corps, en octets
    
- **Transfer-Encoding: chunked** : si prÃ©sent, la longueur nâ€™est pas donnÃ©e dâ€™avance. Le corps est envoyÃ© en plusieurs segments.
    

Sâ€™il nâ€™y a ni `Content-Length` ni `Transfer-Encoding`, alors la fin du corps est dÃ©terminÃ©e par la **fermeture de la connexion**.

## 4.6 â€” Connexion persistance

Par dÃ©faut en HTTP/1.1, les connexions sont **persistantes** (non fermÃ©es immÃ©diatement aprÃ¨s une requÃªte/rÃ©ponse), sauf si lâ€™en-tÃªte `Connection: close` est envoyÃ©.

Cela permet dâ€™envoyer plusieurs requÃªtes sur la mÃªme connexion TCP sans lâ€™ouvrir et la fermer Ã  chaque fois.

---

# RFC 2616 â€” Section 5 : Request

## 5.1 â€” Ligne de requÃªte (Request-Line)

La ligne de requÃªte est la premiÃ¨re ligne dâ€™un message HTTP Ã©mis par un client.

Elle a la forme suivante :

**Method SP Request-URI SP HTTP-Version CRLF**

Exemple :  
GET /index.html HTTP/1.1

- **Method** : la mÃ©thode HTTP (GET, POST, etc.)
    
- **Request-URI** : lâ€™identifiant de la ressource demandÃ©e
    
- **HTTP-Version** : la version du protocole utilisÃ©e
    

Cette ligne est suivie des en-tÃªtes, dâ€™une ligne vide, puis Ã©ventuellement dâ€™un corps.


## 5.1.1 â€” MÃ©thodes HTTP

Les mÃ©thodes dÃ©finissent lâ€™action Ã  effectuer sur la ressource.

Les mÃ©thodes standard de HTTP/1.1 sont :

- **GET** : demande une reprÃ©sentation de la ressource. Ne doit pas avoir d'effet secondaire.
    
- **HEAD** : identique Ã  GET, mais sans le corps de la rÃ©ponse.
    
- **POST** : soumet des donnÃ©es Ã  traiter (formulaire, uploadâ€¦).
    
- **PUT** : remplace ou crÃ©e une ressource Ã  lâ€™URI spÃ©cifiÃ©e.
    
- **DELETE** : supprime la ressource ciblÃ©e.
    
- **OPTIONS** : interroge le serveur sur les capacitÃ©s disponibles.
    
- **TRACE** : retourne la requÃªte telle que reÃ§ue par le serveur (utilisÃ© pour le dÃ©bogage).
    
- **CONNECT** : Ã©tablit un tunnel TCP, typiquement utilisÃ© pour le HTTPS via proxy.
    

> Remarque : Les mÃ©thodes doivent Ãªtre reconnues par le serveur. Si une mÃ©thode nâ€™est pas comprise, le serveur doit renvoyer un code 501 (Not Implemented).


## 5.1.2 â€” URI de requÃªte (Request-URI)

Lâ€™URI de la requÃªte identifie la ressource ciblÃ©e.

Il peut avoir lâ€™une des formes suivantes :

- **Absolute URI** : utilisÃ© principalement par les proxies (`http://example.com/index.html`)
    
- **Absolute path** : la forme la plus courante (`/index.html`)
    
- **Authority** : utilisÃ© avec la mÃ©thode `CONNECT` (`www.example.com:443`)
    
- **"*â€** : signifie â€œtoutes les ressourcesâ€ ; utilisÃ© avec la mÃ©thode `OPTIONS`
    

> Remarque : Le serveur utilise lâ€™en-tÃªte `Host` en HTTP/1.1 pour dÃ©terminer quel hÃ´te est concernÃ© par la requÃªte.


## 5.2 â€” En-tÃªtes de requÃªte (Request Headers)

Les en-tÃªtes de requÃªte sont utilisÃ©s pour :

- transmettre des **informations sur le client** (ex : `User-Agent`, `Referer`)
    
- **dÃ©finir les prÃ©fÃ©rences du client** (ex : `Accept`, `Accept-Language`)
    
- **contrÃ´ler la requÃªte** elle-mÃªme (`Expect`, `Max-Forwards`, etc.)
    

Les types dâ€™en-tÃªtes peuvent Ãªtre regroupÃ©s en trois catÃ©gories :

1. **En-tÃªtes gÃ©nÃ©raux** : valables pour la requÃªte et la rÃ©ponse (ex : `Date`, `Connection`)
    
2. **En-tÃªtes spÃ©cifiques Ã  la requÃªte** : influencent le traitement (ex : `Accept`, `Host`)
    
3. **En-tÃªtes dâ€™entitÃ©** : dÃ©crivent le corps du message (ex : `Content-Type`, `Content-Length`)
    

## 5.3 â€” Host Header (obligatoire en HTTP/1.1)

Le champ `Host` est **obligatoire** dans toutes les requÃªtes HTTP/1.1.

Il permet de spÃ©cifier le **nom de domaine** ciblÃ© par la requÃªte, ce qui est indispensable pour lâ€™hÃ©bergement virtuel.

Exemple :  
Host: [www.example.com](http://www.example.com/)

Si lâ€™en-tÃªte `Host` est absent, le serveur doit rÃ©pondre avec un code **400 Bad Request**.


---

# RFC 2616 â€” Section 6 : Response

# 6.1 â€” Ligne de statut (Status-Line)

La ligne de statut est la premiÃ¨re ligne dâ€™une rÃ©ponse HTTP envoyÃ©e par le serveur.

Format :  
**HTTP-Version SP Status-Code SP Reason-Phrase CRLF**

Exemple :  
HTTP/1.1 200 OK

- **HTTP-Version** : version du protocole utilisÃ©e
    
- **Status-Code** : code numÃ©rique indiquant le rÃ©sultat
    
- **Reason-Phrase** : texte lisible dÃ©crivant le statut
    

Le champ Reason-Phrase est fourni Ã  titre indicatif, mais les clients doivent se fier uniquement au code numÃ©rique.

# 6.2 â€” Codes de statut (Status Codes)

Les codes de statut HTTP sont regroupÃ©s en 5 classes principales selon le premier chiffre :

- **1xx** (Information) : la requÃªte a Ã©tÃ© reÃ§ue et continue Ã  Ãªtre traitÃ©e
    
- **2xx** (SuccÃ¨s) : la requÃªte a Ã©tÃ© reÃ§ue, comprise et acceptÃ©e
    
- **3xx** (Redirection) : des actions supplÃ©mentaires sont nÃ©cessaires pour terminer la requÃªte
    
- **4xx** (Erreur client) : la requÃªte comporte une erreur du cÃ´tÃ© client
    
- **5xx** (Erreur serveur) : le serveur nâ€™a pas pu traiter une requÃªte valide
    

Chaque code est suivi dâ€™un message explicatif (Reason-Phrase), comme "OK" pour 200 ou "Not Found" pour 404.

# 6.3 â€” En-tÃªtes de rÃ©ponse (Response Headers)

Les en-tÃªtes de rÃ©ponse permettent de transmettre des informations utiles sur :

- Le serveur (`Server`, `Date`)
    
- La ressource (`Content-Type`, `Content-Length`, `Last-Modified`)
    
- Le comportement de la connexion (`Connection`, `Keep-Alive`)
    
- Le cache (`Cache-Control`, `Expires`, `ETag`)
    

Les en-tÃªtes de rÃ©ponse, comme ceux de requÃªte, sont divisÃ©s en :

- **En-tÃªtes gÃ©nÃ©raux** : communs Ã  requÃªte et rÃ©ponse
    
- **En-tÃªtes de rÃ©ponse spÃ©cifiques** : propres au serveur et Ã  la ressource
    
- **En-tÃªtes d'entitÃ©** : dÃ©crivent le contenu de la rÃ©ponse
    

# 6.4 â€” Corps de la rÃ©ponse (Response Body)

Le corps contient les **donnÃ©es renvoyÃ©es au client**, gÃ©nÃ©ralement une reprÃ©sentation de la ressource demandÃ©e.

Il est prÃ©sent dans la plupart des rÃ©ponses, sauf :

- RÃ©ponses `1xx`, `204 No Content`, `304 Not Modified`
    
- RequÃªtes `HEAD`, qui ne doivent renvoyer que les en-tÃªtes
    

Le corps est encodÃ© et typÃ© selon les en-tÃªtes :

- `Content-Type` : type MIME (ex : `text/html`)
    
- `Content-Encoding` : compression Ã©ventuelle (ex : `gzip`)
    
- `Content-Length` ou `Transfer-Encoding` : indiquent la taille ou le mode de transmission


---

# RFC 2616 â€” Section 7 : Entity

# 7.1 â€” Quâ€™est-ce quâ€™une entitÃ© ?

Une **entitÃ©** dans HTTP correspond Ã  **lâ€™information transmise avec une requÃªte ou une rÃ©ponse**. Elle est composÃ©e de deux parties :

1. **En-tÃªtes dâ€™entitÃ©** (entity headers)
    
2. **Corps de lâ€™entitÃ©** (entity body), câ€™est-Ã -dire les donnÃ©es proprement dites
    

Les entitÃ©s sont prÃ©sentes dans :

- les requÃªtes contenant des donnÃ©es (ex : POST, PUT)
    
- les rÃ©ponses contenant du contenu (ex : GET, 200 OK)
    

# 7.2 â€” En-tÃªtes dâ€™entitÃ© (Entity Headers)

Ces en-tÃªtes fournissent des **mÃ©tadonnÃ©es** dÃ©crivant le contenu de lâ€™entitÃ©.

En-tÃªtes dÃ©finis dans HTTP/1.1 :

- `Content-Type` : type MIME du contenu
    
- `Content-Encoding` : transformation appliquÃ©e au contenu
    
- `Content-Language` : langue utilisÃ©e
    
- `Content-Length` : taille en octets du corps
    
- `Content-Location` : URI de la reprÃ©sentation envoyÃ©e
    
- `Content-MD5` : empreinte du contenu
    
- `Last-Modified` : date de derniÃ¨re modification de la ressource
    
- `Expires` : date aprÃ¨s laquelle le contenu est considÃ©rÃ© pÃ©rimÃ©
    
- `ETag` : identifiant unique de version du contenu
    

Ces en-tÃªtes peuvent Ãªtre utilisÃ©s pour :

- informer le client sur le format ou la validitÃ© du contenu
    
- aider Ã  la mise en cache et Ã  la nÃ©gociation de contenu
    
- dÃ©tecter les modifications entre versions successives dâ€™une ressource
    

# 7.3 â€” Corps de lâ€™entitÃ© (Entity Body)

Le corps de lâ€™entitÃ© contient les **donnÃ©es rÃ©elles** Ã  transmettre, comme :

- une page HTML
    
- un fichier image, JSON, XML, etc.
    
- un flux binaire encodÃ©
    

Le corps peut Ãªtre :

- **absent** (ex : requÃªte GET sans payload)
    
- **prÃ©sent et vide** (Content-Length: 0)
    
- **prÃ©sent avec une taille connue ou encodÃ©e par blocs (`chunked`)**
    

Sa longueur est dÃ©terminÃ©e par :

- `Content-Length` (taille exacte)
    
- `Transfer-Encoding` (encodage progressif)
    

Le corps est optionnel mais doit Ãªtre interprÃ©tÃ© selon les en-tÃªtes dâ€™entitÃ© fournis.

# 7.4 â€” EntitÃ© vs Ressource

Une entitÃ© est **une reprÃ©sentation** dâ€™une ressource **Ã  un instant donnÃ©**.  
Elle nâ€™est pas la ressource elle-mÃªme.

Par exemple :

- Une ressource `/image.jpg` peut Ãªtre reprÃ©sentÃ©e par diffÃ©rentes entitÃ©s (JPEG compressÃ©, PNG, etc.)
    
- La ressource peut Ã©voluer dans le temps, chaque version ayant une entitÃ© diffÃ©rente (`ETag`, `Last-Modified`)
    

---

# RFC 2616 â€” Section 8 : Connections

# 8.1 â€” Connexions persistantes

En HTTP/1.0, une nouvelle connexion TCP Ã©tait ouverte pour chaque requÃªte/rÃ©ponse.  
En HTTP/1.1, les **connexions persistantes** sont introduites par dÃ©faut, sauf indication contraire.

Cela signifie quâ€™une mÃªme connexion TCP peut Ãªtre rÃ©utilisÃ©e pour **plusieurs requÃªtes et rÃ©ponses**, ce qui amÃ©liore considÃ©rablement les performances rÃ©seau.

## Avantages :

- Moins de surcharge liÃ©e Ã  lâ€™Ã©tablissement de connexions TCP
    
- Moins de latence globale
    
- RÃ©duction du nombre de ports utilisÃ©s simultanÃ©ment
    

## MÃ©canisme :

- Par dÃ©faut, les connexions HTTP/1.1 sont **"keep-alive"**.
    
- Pour fermer explicitement la connexion, un en-tÃªte `Connection: close` doit Ãªtre envoyÃ©.
    
- Le client peut envoyer plusieurs requÃªtes consÃ©cutives (pipelining), bien que ce soit rarement utilisÃ©.
    

# 8.1.1 â€” RÃ©utilisation d'une connexion

Le serveur **peut** garder une connexion ouverte aprÃ¨s avoir envoyÃ© une rÃ©ponse, si :

- Il est sÃ»r que la requÃªte a Ã©tÃ© complÃ¨tement reÃ§ue
    
- Aucune erreur de parsing nâ€™a eu lieu
    

Sinon, il **doit** fermer la connexion pour Ã©viter les incohÃ©rences.

# 8.1.2 â€” En-tÃªte `Connection`

L'en-tÃªte `Connection` permet de spÃ©cifier les options spÃ©cifiques Ã  une connexion.

Exemples :

- `Connection: close` â†’ demande de fermer la connexion aprÃ¨s la rÃ©ponse
    
- `Connection: keep-alive` â†’ utilisÃ©e en HTTP/1.0 pour activer la persistance
    

En HTTP/1.1, la persistance est **automatique**, donc `Connection: keep-alive` est implicite.

# 8.2 â€” Pipelining de requÃªtes

Le **pipelining** permet Ã  un client dâ€™envoyer plusieurs requÃªtes **sans attendre les rÃ©ponses** correspondantes.

Exemple :

- Le client envoie 3 requÃªtes dâ€™un coup (sans attendre les rÃ©ponses)
    
- Le serveur doit **rÃ©pondre dans le mÃªme ordre**
    

### Contraintes :

- Toutes les requÃªtes doivent utiliser la mÃ©thode `safe` (`GET`, `HEAD`, etc.)
    
- Les rÃ©ponses doivent Ãªtre retournÃ©es **dans l'ordre exact des requÃªtes**
    
- Tous les serveurs ne le gÃ¨rent pas bien, et les navigateurs modernes l'ont souvent dÃ©sactivÃ© par dÃ©faut
    

# 8.2.1 â€” Anticipation des corps de requÃªte : Expect / 100-continue

Quand un client veut envoyer une grosse requÃªte (ex : upload via `POST`), il peut dâ€™abord demander au serveur sâ€™il est prÃªt Ã  la traiter.

Cela se fait avec :

```
Expect: 100-continue
```

Le serveur rÃ©pond alors :

- `100 Continue` â†’ OK, le client peut envoyer le corps
    
- Un autre code dâ€™erreur â†’ inutile dâ€™envoyer le corps
    

Ce mÃ©canisme Ã©vite dâ€™envoyer un corps volumineux inutilement, si le serveur doit refuser la requÃªte.


---

# RFC 2616 â€” Section 9 : Method Definitions

Cette section dÃ©crit en dÃ©tail les mÃ©thodes HTTP standard dÃ©finies par le protocole.  
Chaque mÃ©thode spÃ©cifie une **action sÃ©mantique** Ã  effectuer sur une ressource.

# 9.1 â€” SÃ©curitÃ© des mÃ©thodes

Certaines mÃ©thodes sont dites :

- **Safe** : elles n'ont **pas d'effet secondaire** sur le serveur. Elles servent Ã  **rÃ©cupÃ©rer de l'information** sans modifier dâ€™Ã©tat. Exemple : `GET`, `HEAD`.
    
- **Idempotentes** : une requÃªte rÃ©pÃ©tÃ©e **nâ€™aura pas dâ€™effet supplÃ©mentaire**. Exemple : `PUT`, `DELETE`, `GET`. Cela ne veut pas dire quâ€™elles sont sÃ»res, mais quâ€™elles ne produisent pas dâ€™effet cumulÃ©.
    

# 9.2 â€” GET

- RÃ©cupÃ¨re une reprÃ©sentation de la ressource.
    
- Ne doit pas avoir dâ€™effets secondaires (safe).
    
- Les donnÃ©es peuvent Ãªtre mises en cache.
    
- Aucune entitÃ© ne doit Ãªtre incluse dans la requÃªte.
    

# 9.3 â€” HEAD

- Identique Ã  `GET`, mais sans le corps de la rÃ©ponse.
    
- Sert souvent Ã  vÃ©rifier la prÃ©sence ou la mise Ã  jour dâ€™une ressource.
    

# 9.4 â€” POST

- Envoie des **donnÃ©es au serveur** pour traitement (ex : formulaire, fichier).
    
- Les donnÃ©es sont incluses dans le corps de la requÃªte.
    
- Le rÃ©sultat peut Ãªtre la crÃ©ation dâ€™une ressource, une mise Ã  jour, ou autre.
    

Exemples dâ€™usage :

- Soumission de formulaire
    
- CrÃ©ation de commentaire
    
- DÃ©clenchement d'une action cÃ´tÃ© serveur
    

# 9.5 â€” PUT

- Remplace ou crÃ©e une ressource **Ã  lâ€™URI spÃ©cifiÃ©e**.
    
- Idempotente : plusieurs requÃªtes identiques produisent le mÃªme rÃ©sultat.
    
- Le client envoie **la reprÃ©sentation complÃ¨te** de la ressource.
    

Exemple :  
`PUT /fichier.txt` avec un corps contenant le fichier Ã  stocker.

# 9.6 â€” DELETE

- Supprime la ressource Ã  lâ€™URI spÃ©cifiÃ©.
    
- Idempotente.
    
- Le serveur **nâ€™est pas obligÃ©** de supprimer rÃ©ellement la ressource, mais il doit renvoyer un code cohÃ©rent (`200`, `202`, `204` ou erreur).
    

# 9.7 â€” TRACE

- Sert Ã  **tester le chemin** qu'une requÃªte parcourt jusqu'au serveur.
    
- Le serveur renvoie dans le corps de la rÃ©ponse **la requÃªte reÃ§ue**, telle quelle.
    
- UtilisÃ© pour le **dÃ©bogage** ou la **transparence des proxies**.
    

# 9.8 â€” OPTIONS

- Renvoie les **mÃ©thodes supportÃ©es** par le serveur ou la ressource.
    
- Ne modifie pas lâ€™Ã©tat du serveur.
    
- Peut sâ€™appliquer Ã  une ressource spÃ©cifique ou Ã  `"*"` (pour interroger le serveur globalement).
    

Exemple :  
`OPTIONS * HTTP/1.1`

# 9.9 â€” CONNECT

- UtilisÃ©e pour **Ã©tablir un tunnel TCP** Ã  travers un proxy HTTP.
    
- Principalement utilisÃ©e pour **le trafic chiffrÃ© TLS/SSL** (ex : HTTPS).
    
- Exemple : `CONNECT www.example.com:443 HTTP/1.1`
    
Voici la **section 10 â€” Status Code Definitions** du RFC 2616, rÃ©digÃ©e en **Markdown simple**, prÃªte Ã  Ãªtre ajoutÃ©e Ã  ton fichier `.md`.


---

# RFC 2616 â€” Section 10 : Status Code Definitions

Les **codes de statut HTTP** indiquent le rÃ©sultat du traitement d'une requÃªte.  
Chaque code est un entier Ã  trois chiffres, souvent accompagnÃ© dâ€™un texte descriptif (**reason-phrase**).

Les codes sont regroupÃ©s en **5 classes** selon leur premier chiffre :

- **1xx â€” Information** : traitement en cours
    
- **2xx â€” SuccÃ¨s** : la requÃªte a rÃ©ussi
    
- **3xx â€” Redirection** : action supplÃ©mentaire requise (souvent suivre une nouvelle URL)
    
- **4xx â€” Erreur client** : problÃ¨me cÃ´tÃ© client
    
- **5xx â€” Erreur serveur** : le serveur nâ€™a pas rÃ©ussi Ã  exÃ©cuter une requÃªte valide
    

# 10.1 â€” 1xx : Informational

RÃ©ponses intermÃ©diaires, rarement utilisÃ©es directement par les clients.

- **100 Continue** : le client peut continuer Ã  envoyer le corps de la requÃªte.
    
- **101 Switching Protocols** : le serveur accepte de changer de protocole (ex : passage Ã  WebSocket).
    

# 10.2 â€” 2xx : Success

La requÃªte a Ã©tÃ© reÃ§ue, comprise et acceptÃ©e.

- **200 OK** : rÃ©ponse rÃ©ussie, corps de rÃ©ponse prÃ©sent.
    
- **201 Created** : ressource crÃ©Ã©e, gÃ©nÃ©ralement aprÃ¨s un `PUT` ou `POST`.
    
- **202 Accepted** : requÃªte acceptÃ©e pour traitement ultÃ©rieur.
    
- **203 Non-Authoritative Information** : la rÃ©ponse est valide mais provient dâ€™une source secondaire.
    
- **204 No Content** : requÃªte rÃ©ussie, mais sans corps de rÃ©ponse.
    
- **205 Reset Content** : le client doit rÃ©initialiser lâ€™Ã©tat du document (ex : formulaire).
    
- **206 Partial Content** : envoi partiel dâ€™un document (ex : tÃ©lÃ©chargement par morceaux).
    

# 10.3 â€” 3xx : Redirection

Le client doit effectuer une action supplÃ©mentaire pour terminer la requÃªte.

- **300 Multiple Choices** : plusieurs reprÃ©sentations possibles.
    
- **301 Moved Permanently** : ressource dÃ©placÃ©e de faÃ§on permanente.
    
- **302 Found** : ressource temporairement dÃ©placÃ©e.
    
- **303 See Other** : le client doit effectuer une requÃªte GET sur une autre URI.
    
- **304 Not Modified** : la ressource nâ€™a pas changÃ© depuis la derniÃ¨re requÃªte.
    
- **305 Use Proxy** : la ressource doit Ãªtre accÃ©dÃ©e via un proxy.
    
- **307 Temporary Redirect** : redirection temporaire sans changement de mÃ©thode.
    

# 10.4 â€” 4xx : Client Error

Erreur liÃ©e Ã  la requÃªte du client.

- **400 Bad Request** : requÃªte mal formÃ©e.
    
- **401 Unauthorized** : authentification requise.
    
- **402 Payment Required** : rÃ©servÃ© Ã  un usage futur.
    
- **403 Forbidden** : accÃ¨s refusÃ©, mÃªme avec authentification.
    
- **404 Not Found** : ressource non trouvÃ©e.
    
- **405 Method Not Allowed** : mÃ©thode non autorisÃ©e pour cette ressource.
    
- **406 Not Acceptable** : aucune version acceptable de la ressource trouvÃ©e.
    
- **407 Proxy Authentication Required** : authentification requise par un proxy.
    
- **408 Request Timeout** : le client a mis trop de temps Ã  envoyer la requÃªte.
    
- **409 Conflict** : conflit avec lâ€™Ã©tat actuel de la ressource.
    
- **410 Gone** : la ressource nâ€™est plus disponible dÃ©finitivement.
    
- **411 Length Required** : le champ `Content-Length` est requis.
    
- **412 Precondition Failed** : une condition dans la requÃªte a Ã©chouÃ©.
    
- **413 Request Entity Too Large** : le corps de la requÃªte est trop volumineux.
    
- **414 Request-URI Too Long** : lâ€™URI de la requÃªte est trop longue.
    
- **415 Unsupported Media Type** : type de contenu non supportÃ©.
    
- **416 Requested Range Not Satisfiable** : plage de donnÃ©es demandÃ©e invalide.
    
- **417 Expectation Failed** : une attente spÃ©cifiÃ©e dans `Expect` nâ€™a pas pu Ãªtre satisfaite.
    

# 10.5 â€” 5xx : Server Error

Erreur du serveur pendant le traitement de la requÃªte.

- **500 Internal Server Error** : erreur gÃ©nÃ©rique cÃ´tÃ© serveur.
    
- **501 Not Implemented** : mÃ©thode non prise en charge par le serveur.
    
- **502 Bad Gateway** : rÃ©ponse invalide reÃ§ue dâ€™un serveur en amont.
    
- **503 Service Unavailable** : le serveur est temporairement indisponible (surcharge, maintenanceâ€¦).
    
- **504 Gateway Timeout** : dÃ©lai dÃ©passÃ© pour une rÃ©ponse dâ€™un serveur en amont.
    
- **505 HTTP Version Not Supported** : version du protocole non supportÃ©e.


---

# RFC 2616 â€” Section 11 : Access Authentication

HTTP/1.1 inclut un mÃ©canisme standardisÃ© dâ€™**authentification** d'accÃ¨s pour protÃ©ger les ressources.

Lâ€™authentification HTTP repose sur deux composants principaux :

- Le **client**, qui fournit des identifiants
    
- Le **serveur**, qui exige une authentification avant de dÃ©livrer la ressource
    

# 11.1 â€” GÃ©nÃ©ralitÃ©s

Lâ€™authentification se fait grÃ¢ce Ã  des **en-tÃªtes spÃ©cifiques** Ã©changÃ©s entre client et serveur.

- Le serveur envoie un **code 401 Unauthorized** avec lâ€™en-tÃªte `WWW-Authenticate`
    
- Le client rÃ©pond avec lâ€™en-tÃªte `Authorization`, contenant les identifiants
    

Ce mÃ©canisme est **stateless** : chaque requÃªte nÃ©cessitant une authentification doit inclure les informations d'identification.

# 11.2 â€” WWW-Authenticate

Cet en-tÃªte est envoyÃ© par le serveur pour indiquer **quelle mÃ©thode dâ€™authentification** il attend.

Format gÃ©nÃ©ral :  
WWW-Authenticate: realm=""

Exemples :

- WWW-Authenticate: Basic realm="Espace sÃ©curisÃ©"
    
- WWW-Authenticate: Digest realm="Domaine sÃ©curisÃ©", ...
    

Le champ `realm` sert Ã  **identifier la zone protÃ©gÃ©e** pour laquelle lâ€™authentification est requise.

# 11.3 â€” Authorization

Câ€™est la rÃ©ponse du client Ã  une demande dâ€™authentification.  
Elle contient les identifiants dans un format dÃ©pendant de la mÃ©thode choisie (`Basic`, `Digest`, etc.)

Exemple :  
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

> âš ï¸ Le schÃ©ma Basic encode simplement les identifiants en Base64, sans chiffrement â€” ce nâ€™est **pas sÃ©curisÃ©** sans HTTPS.

# 11.4 â€” Proxy-Authenticate et Proxy-Authorization

Un **proxy** peut Ã©galement exiger une authentification :

- `Proxy-Authenticate` : Ã©quivalent de `WWW-Authenticate`, mais pour un proxy
    
- `Proxy-Authorization` : Ã©quivalent de `Authorization`, mais envoyÃ© au proxy
    

Ce mÃ©canisme est utilisÃ© pour **lâ€™accÃ¨s contrÃ´lÃ© Ã  des passerelles ou rÃ©seaux protÃ©gÃ©s**.


---

# RFC 2616 â€” Section 12 : Content Negotiation

La **nÃ©gociation de contenu** permet Ã  un serveur HTTP de proposer la **meilleure reprÃ©sentation dâ€™une ressource** en fonction des prÃ©fÃ©rences du client.

Une mÃªme ressource peut exister sous plusieurs formes :

- DiffÃ©rentes langues (franÃ§ais, anglaisâ€¦)
    
- DiffÃ©rents formats (HTML, JSON, XMLâ€¦)
    
- DiffÃ©rents encodages (compressÃ© ou nonâ€¦)
    

Le client peut indiquer ses prÃ©fÃ©rences via plusieurs en-tÃªtes, et le serveur choisit la version la plus appropriÃ©e.

# 12.1 â€” Dimensions de la nÃ©gociation

Trois principales dimensions sont utilisÃ©es :

- **Type de mÃ©dia** (`Accept`) : indique les formats prÃ©fÃ©rÃ©s (ex: `text/html`, `application/json`)
    
- **Langue** (`Accept-Language`) : indique les langues prÃ©fÃ©rÃ©es (ex: `fr`, `en-US`)
    
- **Encodage** (`Accept-Encoding`) : indique les codages de compression acceptÃ©s (ex: `gzip`, `deflate`)
    
- **Jeu de caractÃ¨res** (`Accept-Charset`) : indique les encodages de caractÃ¨res prÃ©fÃ©rÃ©s (ex: `UTF-8`, `ISO-8859-1`)
    

Chaque champ peut inclure un **paramÃ¨tre de qualitÃ© `q`** (entre 0 et 1) pour indiquer le niveau de prÃ©fÃ©rence.

Exemple :  
Accept-Language: fr, en;q=0.8, de;q=0.5

# 12.2 â€” MÃ©canismes de nÃ©gociation

Deux approches sont possibles :

## NÃ©gociation cÃ´tÃ© serveur (server-driven)

- Le serveur choisit la reprÃ©sentation Ã  renvoyer en fonction des en-tÃªtes `Accept-*`
    
- Avantage : transparent pour le client
    
- InconvÃ©nient : le serveur peut se tromper (ambiguÃ¯tÃ©)
    

## NÃ©gociation cÃ´tÃ© client (agent-driven)

- Le serveur renvoie une rÃ©ponse listant les versions possibles (ex: `300 Multiple Choices`)
    
- Le **client choisit** ensuite la version souhaitÃ©e
    
- Moins utilisÃ© en pratique, mais plus explicite
    

# 12.3 â€” Transparence de la nÃ©gociation

Le protocole HTTP permet la nÃ©gociation **sans changer lâ€™URI** de la ressource.  
Autrement dit, plusieurs reprÃ©sentations peuvent Ãªtre servies sous la **mÃªme URL**, en fonction du contexte de la requÃªte.

Exemple :  
`GET /manuel` peut renvoyer :

- `manuel.html` si `Accept: text/html`
    
- `manuel.pdf` si `Accept: application/pdf`
    

# 12.4 â€” Caching et nÃ©gociation

La nÃ©gociation peut rendre la mise en cache plus complexe.

Pour cela, les caches HTTP doivent tenir compte des en-tÃªtes de variation via le champ :

`Vary: Accept, Accept-Language`

Cela indique au cache que le contenu dÃ©pend de ces champs, et quâ€™il ne faut pas servir la mÃªme version Ã  tout le monde.

---

# RFC 2616 â€” Section 13 : Caching in HTTP

Le **cache HTTP** permet de stocker localement des rÃ©ponses pour Ã©viter des requÃªtes rÃ©pÃ©tÃ©es identiques.  
Il vise Ã  **amÃ©liorer les performances**, **rÃ©duire la charge rÃ©seau** et **accÃ©lÃ©rer l'affichage** pour l'utilisateur.

Le cache peut Ãªtre :

- cÃ´tÃ© **client** (navigateur)
    
- cÃ´tÃ© **proxy**
    
- ou intÃ©grÃ© dans un **serveur intermÃ©diaire**
    

# 13.1 â€” Buts du cache

- RÃ©duire la latence
    
- RÃ©duire la charge sur les serveurs
    
- RÃ©duire la consommation de bande passante
    
- AmÃ©liorer la rÃ©activitÃ© perÃ§ue par l'utilisateur
    

Mais il ne doit **pas compromettre la cohÃ©rence** des donnÃ©es. HTTP dÃ©finit donc des rÃ¨gles strictes pour dÃ©terminer quand une rÃ©ponse est cacheable.

# 13.2 â€” CacheabilitÃ© des rÃ©ponses

Une rÃ©ponse est **cacheable** si :

- Elle est associÃ©e Ã  un code de statut cacheable (`200`, `203`, `206`, `300`, `301`, `410`)
    
- Elle ne contient pas dâ€™instructions `Cache-Control` ou `Pragma` qui lâ€™interdisent
    
- Elle contient des en-tÃªtes permettant la validation ou lâ€™expiration (`ETag`, `Last-Modified`, `Expires`)
    

Certaines rÃ©ponses (comme `404`, `500`) peuvent Ãªtre mises en cache **dans des cas particuliers**.

# 13.3 â€” Validation du cache

Avant dâ€™utiliser une rÃ©ponse stockÃ©e, le cache peut la **valider** auprÃ¨s du serveur avec des en-tÃªtes conditionnels :

- `If-Modified-Since`
    
- `If-None-Match` (avec `ETag`)
    

Le serveur peut alors rÃ©pondre avec :

- `304 Not Modified` : le contenu est encore valide
    
- Une nouvelle version mise Ã  jour
    

# 13.4 â€” ContrÃ´le d'expiration

Pour savoir quand une rÃ©ponse devient obsolÃ¨te, on utilise :

- `Expires` : date/heure prÃ©cise aprÃ¨s laquelle la rÃ©ponse est considÃ©rÃ©e pÃ©rimÃ©e
    
- `Cache-Control: max-age=N` : durÃ©e (en secondes) pendant laquelle la rÃ©ponse est fraÃ®che
    

# 13.5 â€” Cache-Control

Câ€™est lâ€™en-tÃªte central du systÃ¨me de cache HTTP/1.1. Il permet de contrÃ´ler prÃ©cisÃ©ment le comportement du cache.

Exemples de directives :

- `no-cache` : doit valider la rÃ©ponse avant de lâ€™utiliser
    
- `no-store` : ne doit pas stocker la rÃ©ponse du tout
    
- `public` : peut Ãªtre stockÃ©e par tout cache
    
- `private` : seulement pour le cache du client
    
- `max-age=N` : durÃ©e de validitÃ© (en secondes)
    
- `must-revalidate` : doit valider aprÃ¨s expiration
    
- `proxy-revalidate` : idem, mais pour les proxies
    

# 13.6 â€” RequÃªtes non-cacheables

Les requÃªtes contenant :

- `Authorization`
    
- certaines mÃ©thodes (comme `POST`, `PUT`, `DELETE`)
    

ne sont gÃ©nÃ©ralement **pas mises en cache**, sauf si des directives explicites comme `Cache-Control: public` sont prÃ©sentes.

# 13.7 â€” Invalidation du cache

Une entrÃ©e de cache doit Ãªtre invalidÃ©e si :

- La mÃ©thode est autre que `GET` ou `HEAD` (ex : `PUT`, `DELETE`)
    
- Une nouvelle rÃ©ponse a Ã©tÃ© reÃ§ue avec les mÃªmes URI et des champs de validation diffÃ©rents
    

# 13.8 â€” Caches partagÃ©s vs privÃ©s

- **Caches partagÃ©s** : utilisÃ©s par plusieurs utilisateurs (ex : proxy). Doivent respecter strictement les directives.
    
- **Caches privÃ©s** : spÃ©cifiques Ã  un utilisateur (navigateur). Peuvent Ãªtre plus souples, mais doivent respecter les en-tÃªtes comme `private`.
    

# 13.9 â€” Champs Vary

L'en-tÃªte `Vary` indique **quels champs dâ€™en-tÃªte influencent** la rÃ©ponse servie.

Exemple :  
Vary: Accept-Encoding

Cela signifie que le cache doit stocker des versions distinctes selon la valeur de `Accept-Encoding`.


---

# RFC 2616 â€” Section 14 : Header Field Definitions

Cette section dÃ©finit **tous les champs dâ€™en-tÃªte** standards du protocole HTTP/1.1, leur syntaxe et leur signification.

Chaque champ dâ€™en-tÃªte appartient Ã  lâ€™une des catÃ©gories suivantes :

- **En-tÃªtes gÃ©nÃ©raux** : utilisÃ©s aussi bien dans les requÃªtes que dans les rÃ©ponses
    
- **En-tÃªtes de requÃªte** : spÃ©cifiques au client
    
- **En-tÃªtes de rÃ©ponse** : spÃ©cifiques au serveur
    
- **En-tÃªtes dâ€™entitÃ©** : dÃ©crivent le corps du message
    

# 14.1 â€” Accept

Indique les types MIME que le client peut accepter.

Exemple :  
Accept: text/html, application/json;q=0.9, _/_;q=0.8

# 14.2 â€” Accept-Charset

Indique les jeux de caractÃ¨res acceptÃ©s par le client.

Exemple :  
Accept-Charset: utf-8, iso-8859-1;q=0.5

# 14.3 â€” Accept-Encoding

Liste les codages de contenu (compressions) acceptÃ©s.

Exemple :  
Accept-Encoding: gzip, deflate

# 14.4 â€” Accept-Language

SpÃ©cifie les langues acceptÃ©es.

Exemple :  
Accept-Language: fr, en;q=0.8

# 14.5 â€” Accept-Ranges

UtilisÃ© par le serveur pour indiquer quâ€™il accepte les requÃªtes partielles (`Range`).

Exemple :  
Accept-Ranges: bytes

# 14.6 â€” Age

Temps Ã©coulÃ© depuis la gÃ©nÃ©ration de la rÃ©ponse, en secondes (utilisÃ© par les caches).

# 14.7 â€” Allow

Liste des mÃ©thodes autorisÃ©es pour une ressource.

Exemple :  
Allow: GET, POST, OPTIONS

# 14.8 â€” Authorization

Contient les identifiants envoyÃ©s par le client pour accÃ©der Ã  une ressource protÃ©gÃ©e.

# 14.9 â€” Cache-Control

ContrÃ´le le comportement du cache (voir section 13).

# 14.10 â€” Connection

GÃ¨re les options spÃ©cifiques Ã  la connexion (ex: `close`, `keep-alive`).

# 14.11 â€” Content-Encoding

SpÃ©cifie un encodage (ex: compression) appliquÃ© au corps.

# 14.12 â€” Content-Language

Indique la langue du contenu de la rÃ©ponse.

# 14.13 â€” Content-Length

Donne la taille (en octets) du corps de lâ€™entitÃ©.

# 14.14 â€” Content-Location

URI alternative qui identifie la ressource rÃ©elle fournie.

# 14.15 â€” Content-MD5

Hash MD5 du corps, utilisÃ© pour la vÃ©rification dâ€™intÃ©gritÃ©.

# 14.16 â€” Content-Range

UtilisÃ© pour envoyer des **fragments** de ressource (ex : tÃ©lÃ©chargement partiel).

# 14.17 â€” Content-Type

Type MIME du corps (ex: `text/html`, `image/jpeg`).

# 14.18 â€” Date

Date et heure de gÃ©nÃ©ration du message (en GMT).

# 14.19 â€” ETag

Identifiant de version dâ€™une ressource, utilisÃ© pour la validation.

# 14.20 â€” Expect

UtilisÃ© par le client pour indiquer une condition prÃ©alable (ex: `100-continue`).

# 14.21 â€” Expires

Date Ã  partir de laquelle la rÃ©ponse est pÃ©rimÃ©e.

# 14.22 â€” From

Adresse email de lâ€™utilisateur faisant la requÃªte.

# 14.23 â€” Host

Nom de domaine et port de destination (obligatoire en HTTP/1.1).

# 14.24 â€” If-Match / 14.25 â€” If-Modified-Since / 14.26 â€” If-None-Match / 14.27 â€” If-Range / 14.28 â€” If-Unmodified-Since

Famille dâ€™en-tÃªtes utilisÃ©s pour les **requÃªtes conditionnelles**.  
Ils permettent dâ€™Ã©conomiser de la bande passante et dâ€™assurer la cohÃ©rence des mises Ã  jour.

# 14.29 â€” Last-Modified

Date de derniÃ¨re modification de la ressource.

# 14.30 â€” Location

Indique une nouvelle URI pour la redirection.

# 14.31 â€” Max-Forwards

UtilisÃ© avec TRACE et OPTIONS pour limiter le nombre de sauts proxy/gateway.

# 14.32 â€” Pragma

Directive gÃ©nÃ©rale pour le cache (ex: `Pragma: no-cache`, hÃ©ritÃ© de HTTP/1.0).

# 14.33 â€” Proxy-Authenticate / 14.34 â€” Proxy-Authorization

MÃ©canisme dâ€™authentification entre client et proxy.

# 14.35 â€” Range

Permet de demander une **portion** de la ressource (ex: `bytes=500-999`).

# 14.36 â€” Referer

URI de la ressource ayant initiÃ© la requÃªte (typo volontaire dans le RFC : "Referer" au lieu de "Referrer").

# 14.37 â€” Retry-After

SpÃ©cifie combien de temps attendre avant de rÃ©essayer (utilisÃ© avec `503 Service Unavailable`).

# 14.38 â€” Server

Identifie le logiciel serveur HTTP (ex: `Apache/2.4`).

# 14.39 â€” TE

SpÃ©cifie les encodages de transfert acceptÃ©s (`chunked`, `gzip`, etc.).

# 14.40 â€” Trailer

Indique les champs dâ€™en-tÃªte prÃ©sents dans la bande-annonce (`trailer`) dâ€™une rÃ©ponse chunked.

# 14.41 â€” Transfer-Encoding

Indique lâ€™encodage utilisÃ© pour transmettre le corps (`chunked`, etc.)

# 14.42 â€” Upgrade

Permet de demander un changement de protocole (ex : vers HTTP/2, WebSocket).

# 14.43 â€” User-Agent

ChaÃ®ne dâ€™identification du client HTTP (ex: navigateur, botâ€¦).

# 14.44 â€” Vary

Indique quels en-tÃªtes influencent la reprÃ©sentation de la ressource (ex: `Vary: Accept-Language`).

# 14.45 â€” Via

Indique le cheminement d'une requÃªte Ã  travers des proxies.

# 14.46 â€” Warning

Transmet des **informations de diagnostic** (ex : contenu expirÃ© mais encore servi).

# 14.47 â€” WWW-Authenticate

En-tÃªte envoyÃ© par le serveur pour demander une authentification.

---

# RFC 2616 â€” Section 15 : Security Considerations

Cette section dÃ©crit les **principaux risques de sÃ©curitÃ©** liÃ©s au protocole HTTP/1.1 et fournit des recommandations pour les attÃ©nuer.

HTTP Ã©tant un protocole de **texte en clair**, il nâ€™intÃ¨gre **aucun mÃ©canisme natif de chiffrement ou de confidentialitÃ©**.  
Les aspects de sÃ©curitÃ© dÃ©pendent donc fortement de la **conception des applications**, de lâ€™**infrastructure rÃ©seau** et de lâ€™utilisation de protocoles complÃ©mentaires comme **TLS (HTTPS)**.

# 15.1 â€” ConfidentialitÃ©

- Par dÃ©faut, HTTP **ne chiffre aucune donnÃ©e** (en-tÃªtes, URI, corps).
    
- Les informations sensibles (mots de passe, cookies, sessions) peuvent Ãªtre interceptÃ©es par un attaquant si HTTP est utilisÃ© sans chiffrement.
    
- Utiliser **HTTPS (HTTP over TLS)** est fortement recommandÃ© pour toutes les communications sensibles.
    

# 15.2 â€” Authentification

- Le mÃ©canisme dâ€™authentification HTTP de base (`Basic`) **transmet les identifiants en Base64**, ce qui nâ€™est **pas sÃ©curisÃ©** sans HTTPS.
    
- Les implÃ©mentations doivent :
    
    - Toujours **protÃ©ger les Ã©changes dâ€™authentification avec TLS**
        
    - Ã‰viter de stocker les identifiants dans des URI ou des cookies non sÃ©curisÃ©s
        

# 15.3 â€” Spoofing et falsification

- Les **en-tÃªtes HTTP** peuvent Ãªtre falsifiÃ©s, notamment `Referer`, `User-Agent`, `Host`, etc.
    
- Il ne faut **pas faire confiance aveuglÃ©ment** Ã  ces champs cÃ´tÃ© serveur.
    
- Les applications doivent valider et contrÃ´ler explicitement les donnÃ©es critiques.
    

# 15.4 â€” Attaques par redirection

- Les codes `3xx` peuvent rediriger un client vers un **site malveillant**.
    
- Le client doit vÃ©rifier si la redirection est autorisÃ©e ou attendue.
    
- Le serveur doit Ã©viter de construire dynamiquement des redirections Ã  partir de donnÃ©es utilisateur non filtrÃ©es.
    

# 15.5 â€” Injection dâ€™en-tÃªtes

- Certains serveurs vulnÃ©rables peuvent autoriser lâ€™injection de **caractÃ¨res de contrÃ´le** (`\r\n`) dans les en-tÃªtes.
    
- Cela peut conduire Ã  des attaques de type **HTTP Response Splitting**.
    
- Les serveurs doivent **valider rigoureusement** tous les champs dâ€™en-tÃªte construits Ã  partir dâ€™entrÃ©es utilisateur.
    

# 15.6 â€” RequÃªtes inter-sites (Cross-Site Request Forgery)

- HTTP nâ€™a pas de mÃ©canisme intÃ©grÃ© contre les attaques CSRF.
    
- Les applications web doivent mettre en place leurs propres protections (tokens anti-CSRF, vÃ©rification de lâ€™origine...).
    

# 15.7 â€” Exposition dâ€™informations sensibles

- Les en-tÃªtes peuvent **fuiter des donnÃ©es sensibles** : chemins de fichiers, versions de logiciels (`Server`, `User-Agent`, etc.).
    
- Il est recommandÃ© de **limiter les informations exposÃ©es** dans les en-tÃªtes automatiques.
    

# 15.8 â€” Cache et sÃ©curitÃ©

- Un **cache partagÃ©** peut accidentellement stocker une rÃ©ponse contenant des **donnÃ©es privÃ©es**.
    
- Lâ€™en-tÃªte `Cache-Control: private` doit Ãªtre utilisÃ© pour Ã©viter le stockage dans des caches partagÃ©s.
    
- `no-store` empÃªche tout stockage, mÃªme local.
    

# 15.9 â€” Code exÃ©cutable

- HTTP est souvent utilisÃ© pour transfÃ©rer du contenu exÃ©cutable (JavaScript, ActiveX, Java...).
    
- Les navigateurs doivent appliquer des **politiques de sÃ©curitÃ© strictes** :
    
    - ContrÃ´le dâ€™origine (Same-Origin Policy)
        
    - Filtrage du contenu actif
        
    - Limitation des permissions du contenu embarquÃ©
        

---

# RFC 2616 â€” Section 16 : Acknowledgments

Cette section rend hommage aux personnes ayant contribuÃ© de maniÃ¨re significative Ã  la rÃ©daction, lâ€™Ã©volution et la relecture de la spÃ©cification HTTP/1.1.

Le dÃ©veloppement de HTTP/1.1 a Ã©tÃ© possible grÃ¢ce aux travaux initiaux sur HTTP/1.0 et Ã  la collaboration active de nombreux chercheurs, ingÃ©nieurs, universitaires et membres de la communautÃ© IETF.

## Principaux contributeurs citÃ©s

Les auteurs remercient notamment les personnes suivantes pour leur implication, leurs commentaires techniques ou leur relecture attentive :

- Josh Cohen
    
- Roy T. Fielding
    
- Paul Leach
    
- Larry Masinter
    
- Jeffrey Mogul
    
- Henrik Frystyk Nielsen
    
- Dave Kristol
    
- Jim Gettys
    
- Koen Holtman
    
- Shel Kaphan
    
- Phillip M. Hallam-Baker
    
- John Franks
    
- Ari Luotonen
    
- Daniel W. Connolly
    
- et beaucoup d'autres membres actifs du groupe de travail HTTP-WG
    

Le RFC reconnaÃ®t Ã©galement lâ€™apport fondamental du **World Wide Web Consortium (W3C)** et des implÃ©menteurs de serveurs et navigateurs web, dont les retours concrets ont permis dâ€™affiner le protocole.

## Mention spÃ©ciale

Un remerciement particulier est adressÃ© Ã  **Tim Berners-Lee**, inventeur du World Wide Web, pour avoir posÃ© les bases sur lesquelles HTTP a Ã©tÃ© conÃ§u.
Voici la **section 17 â€” References** du RFC 2616, rÃ©digÃ©e en **Markdown simple**, pour que tu puisses l'ajouter directement Ã  ton fichier `.md` :

---

# RFC 2616 â€” Section 17 : References

La section des rÃ©fÃ©rences du RFC 2616 liste tous les documents et normes sur lesquels sâ€™appuie la spÃ©cification HTTP/1.1.  
Elle est divisÃ©e en deux catÃ©gories :

## 17.1 â€” Normatives References (RÃ©fÃ©rences normatives)

Ce sont les documents **essentiels** pour comprendre ou implÃ©menter HTTP/1.1.  
Ils dÃ©finissent les Ã©lÃ©ments de base utilisÃ©s dans le RFC.

- **[RFC 822]** â€” Standard for the format of ARPA Internet text messages (structure des en-tÃªtes, base du format texte)
    
- **[RFC 1123]** â€” Requirements for Internet Hosts â€“ Application and Support (usage des dates, conformitÃ©)
    
- **[RFC 2045]** â€” MIME Part One: Format of Internet Message Bodies
    
- **[RFC 2046]** â€” MIME Part Two: Media Types (dÃ©finition des types MIME)
    
- **[RFC 2145]** â€” Use and Interpretation of HTTP Version Numbers
    
- **[RFC 2119]** â€” Key words for use in RFCs to Indicate Requirement Levels (MUST, SHOULD, MAY, etc.)
    
- **[RFC 2183]** â€” Content-Disposition Header Field (gestion des fichiers joints)
    

## 17.2 â€” Informative References (RÃ©fÃ©rences informatives)

Ces documents ne sont **pas requis** pour implÃ©menter HTTP/1.1, mais fournissent un **contexte utile** ou une perspective historique.

- **[RFC 1945]** â€” HTTP/1.0 (ancienne version du protocole)
    
- **[RFC 1864]** â€” The Content-MD5 Header Field (utilisation des hash MD5 dans les entitÃ©s)
    
- **[RFC 2047]** â€” MIME Header Extensions for Non-ASCII Text
    
- **[RFC 2068]** â€” PremiÃ¨re version du draft HTTP/1.1 (remplacÃ©e par le prÃ©sent RFC)
    
- **[RFC 2617]** â€” HTTP Authentication: Basic and Digest Access Authentication
    

Ces rÃ©fÃ©rences complÃ¨tent la comprÃ©hension du protocole et montrent son Ã©volution progressive dans lâ€™Ã©cosystÃ¨me Internet.
