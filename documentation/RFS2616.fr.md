# RFC 2616 — Section 1 : Introduction

## Objectif du protocole HTTP/1.1

HTTP (HyperText Transfer Protocol) est un **protocole d'application** conçu pour permettre la communication entre des **systèmes distribués, collaboratifs et hypermédia**.

Il s’agit d’un protocole :
- **Orienté requête/réponse**, principalement entre un **client** (ex. navigateur) et un **serveur**.
- **Sans état** (*stateless*) : chaque requête est **indépendante** des précédentes ; le serveur ne conserve pas de contexte entre deux requêtes.
- **Extensible**, conçu pour supporter de **nouvelles méthodes**, **en-têtes**, ou **types de médias**.
- **Générique**, pouvant servir à transférer **toute forme de données** (pas seulement du HTML).
- **Transport-indépendant** : même si HTTP fonctionne le plus souvent au-dessus de TCP, il pourrait être utilisé avec d'autres protocoles fiables.

## Contexte historique

- HTTP a été initialement conçu pour le projet **World Wide Web**.
- HTTP/1.0 (décrit dans le RFC 1945) a introduit la structure de base du protocole.
- HTTP/1.1 (ce RFC) **étend et améliore** HTTP/1.0, notamment avec :
  - **Connexions persistantes** (réutilisation de la connexion TCP)
  - **Contrôle de cache plus robuste**
  - **Support explicite des hôtes virtuels** (via l'en-tête `Host`)
  - **Gestion fine des erreurs** et du **contenu négocié**

## Déploiement

- HTTP/1.1 a été conçu pour **remplacer progressivement HTTP/1.0**.
- Il est **rétrocompatible** avec HTTP/1.0 à certains égards, mais des modifications ont été apportées pour clarifier et améliorer la norme.

## Interopérabilité

- HTTP/1.1 vise à **favoriser l’interopérabilité** entre divers logiciels et plateformes.
- Il impose des **contraintes plus strictes** sur les implémentations pour éviter les interprétations ambigües du protocole.
- Le protocole repose sur une syntaxe **claire, standardisée, extensible** (utilisant une grammaire formelle décrite dans la section 2).

## Structure du document

Ce document (RFC 2616) est une **spécification complète** du protocole HTTP/1.1. Il couvre :
- Les **messages** (requêtes et réponses)
- La **sémantique** des méthodes HTTP
- Les **codes de statut**
- Les **en-têtes**
- La **gestion du cache**, des **connexions**, de **l’authentification**, et de la **sécurité**

> 💡 Remarque : HTTP/1.1 est un protocole **de plus haut niveau** que TCP. Il s’appuie sur des services de transport fiables (comme TCP) mais ne traite pas directement des paquets réseau.

---

# RFC 2616 — Section 2 : Conventions de Notation et Grammaire Générique

## 2.1 — Mots-clés normatifs

Le document utilise les mots-clés suivants, conformément au RFC 2119, pour indiquer le niveau d’exigence d’une règle :

- **MUST** / **REQUIRED** : la règle est obligatoire.
    
- **MUST NOT** : la règle est strictement interdite.
    
- **SHOULD** : il est fortement recommandé de suivre la règle, sauf exception justifiée.
    
- **SHOULD NOT** : il est déconseillé de suivre la règle, sauf cas exceptionnel.
    
- **MAY** : la règle est optionnelle.
    

Ces mots-clés sont utilisés dans tout le document pour indiquer ce qui est obligatoire, recommandé ou facultatif.

## 2.2 — Grammaire générique (Augmented BNF)

La syntaxe utilisée est appelée **ABNF** (Augmented Backus-Naur Form), dérivée du RFC 822.

Elle permet de décrire la structure formelle des éléments HTTP : lignes de requête, en-têtes, corps de message, etc.

## 2.3 — Symboles utilisés dans la grammaire

- `"` : chaîne littérale (exemple : `"GET"`)
    
- `|` : opérateur "ou" logique (exemple : `GET | POST`)
    
- `*` : 0 ou plusieurs répétitions
    
- `+` : 1 ou plusieurs répétitions
    
- `?` : 0 ou 1 répétition
    
- `()` : regroupe plusieurs éléments
    
- `=` ou `::=` : définition d’une règle
    

**Exemple de règle :**

method = "GET" | "POST" | "PUT" | "DELETE"

## 2.4 — Jeu de caractères

- Les mots-clés et en-têtes sont en **US-ASCII** (7 bits).
    
- Les noms d’en-tête ne sont **pas sensibles à la casse**.
    
- Le corps du message peut contenir des données binaires, mais les métadonnées restent en ASCII.
    

## 2.5 — Linéarisation (folding)

- Certains champs d’en-tête peuvent être écrits sur plusieurs lignes.
    
- Les lignes supplémentaires doivent **commencer par un espace ou une tabulation**.
    
- Ce comportement (appelé "folding") est **obsolète**, mais mentionné pour compatibilité.
    

**Exemple :**

Content-Type: text/html;  
charset=UTF-8

## 2.6 — Éléments lexicaux fondamentaux

- **token** : suite de caractères alphanumériques autorisés (pas d'espaces, ni de séparateurs spéciaux).
    
- **separators** : ensemble de caractères interdits dans un token :  
    `()<>@,;:\"/[]?={} \t`
    
- **quoted-string** : chaîne entre guillemets, pouvant contenir des caractères échappés avec `\`.
    

**Exemple de règle :**

token = 1*<tout caractère sauf séparateurs et caractères de contrôle>

## 2.7 — Utilité pour les implémentations

- La grammaire permet d’éviter les **ambiguïtés** dans les implémentations de clients et serveurs HTTP.
    
- Elle est utilisée dans toutes les autres sections du RFC pour **formuler précisément les règles syntaxiques**.
    
---

# RFC 2616 — Section 3 : Paramètres du Protocole

## 3.1 — Version du protocole HTTP

La version du protocole est indiquée dans chaque message HTTP selon la forme suivante :

HTTP-Version = "HTTP" "/" chiffre "." chiffre

Exemples :

- HTTP/1.0
    
- HTTP/1.1
    

Le client annonce cette version dans la ligne de requête. Le serveur répond généralement avec la même version, ou celle qu’il prend en charge.

**Remarque** : Un serveur **ne doit pas** renvoyer une version plus récente que celle qu’il comprend réellement.

---

## 3.2 — Identificateurs de ressource (URI)

Les ressources HTTP sont identifiées par des **URI** (Uniform Resource Identifiers). Ces URI peuvent prendre plusieurs formes selon leur contexte :

- **Request-URI** : URI dans la ligne de requête
    
- **absoluteURI** : commence par le schéma (ex : `http://example.com/index.html`)
    
- **relativeURI** : relatif au contexte (ex : `/index.html`)
    
- **en-tête Host** : obligatoire en HTTP/1.1 pour désigner le nom de domaine (utilisé pour l’hébergement virtuel)
    

**Exemple** :  
GET /index.html HTTP/1.1  
Host: [www.example.com](http://www.example.com/)

---

## 3.3 — Dates et heures

Les dates HTTP doivent être exprimées en format **RFC 1123**, en anglais, à l’heure **GMT**.

Format normalisé :  
Sun, 06 Nov 1994 08:49:37 GMT

Autres formats acceptés (pour compatibilité descendante) :

- RFC 850 : Sunday, 06-Nov-94 08:49:37 GMT
    
- asctime() : Sun Nov 6 08:49:37 1994
    

**Important** : HTTP/1.1 exige que **les serveurs utilisent uniquement le format RFC 1123 dans leurs réponses**.

Les dates sont utilisées notamment dans les en-têtes :

- `Date`
    
- `Expires`
    
- `Last-Modified`
    
- `If-Modified-Since`
    

---

## 3.4 — Types de média (Media Types)

Le contenu d’un message HTTP est décrit par son **type MIME**.

Syntaxe :  
media-type = type "/" subtype *( ";" parameter )

Exemples :

- text/html
    
- text/plain; charset=UTF-8
    
- application/json
    
- image/png
    

Le paramètre `charset` est couramment utilisé pour les types `text/*`.

---

## 3.5 — Langues naturelles

Le client peut indiquer ses préférences linguistiques avec l’en-tête `Accept-Language`.

Exemples de codes de langue :

- fr
    
- en
    
- en-US
    
- fr-CA
    

Cela permet au serveur de choisir la **version localisée** la plus adaptée du contenu (voir négociation de contenu).

---

## 3.6 — Encodage de transfert (Transfer-Encoding)

Cet encodage décrit **comment le contenu est envoyé**, indépendamment de son format initial.

Encodages possibles :

- chunked (par blocs) — utilisé lorsque la taille n’est pas connue à l’avance
    
- gzip, compress — pour la compression des données
    

**chunked** est obligatoire dans certains cas, notamment pour les réponses générées dynamiquement.

---

## 3.7 — Encodage de contenu (Content-Encoding)

Le champ `Content-Encoding` indique une **transformation appliquée au contenu original**, que le client devra **inverser** pour lire la ressource.

Exemples :

- gzip
    
- deflate
    
- compress
    

Cela permet la compression de fichiers avant envoi, sans changer le type MIME déclaré.

---

## 3.8 — Codage des caractères (Charset)

Les contenus textuels peuvent indiquer le jeu de caractères utilisé grâce au paramètre `charset` dans l’en-tête `Content-Type`.

Exemples :

- ISO-8859-1 (valeur par défaut si non précisé)
    
- UTF-8
    
- US-ASCII
    

Exemple d’en-tête :  
Content-Type: text/html; charset=UTF-8

---

## 3.9 — Qualité de préférence (poids)

Certaines valeurs utilisent un **coefficient de qualité** (`q`) pour exprimer une préférence relative (entre 0 et 1).

Exemple :  
Accept-Language: fr, en;q=0.8, de;q=0.5

Signifie : préférence pour le français, ensuite l’anglais, puis l’allemand.

---

# RFC 2616 — Section 4 : HTTP Message

## Structure générale

HTTP est basé sur un modèle **requête/réponse** entre un client et un serveur.

Chaque message HTTP (qu’il s’agisse d’une requête ou d’une réponse) est composé de trois parties :

1. **Start-Line** : ligne de requête (pour un client) ou ligne de statut (pour un serveur)
    
2. **Header Fields** : ensemble de champs d’en-tête décrivant la requête ou la réponse
    
3. **Message Body** (facultatif) : contient les données associées (ex. : contenu HTML, image, JSON…)
    

## 4.1 — Message Format

La structure complète d’un message est la suivante :

- Une ligne de départ (Request-Line ou Status-Line)
    
- Zéro ou plusieurs lignes d’en-tête (Header Fields)
    
- Une ligne vide (séparateur entre les en-têtes et le corps)
    
- Un corps de message facultatif
    

**Exemple simplifié de requête HTTP :**

GET /index.html HTTP/1.1  
Host: [www.example.com](http://www.example.com/)  
Accept: text/html

[ligne vide]  
[corps du message, s’il y en a un]

## 4.2 — Ligne de départ (Start-Line)

La ligne de départ est :

- Une **Request-Line** pour une requête :
    
    - format : `Method SP Request-URI SP HTTP-Version CRLF`
        
    - exemple : `GET /page.html HTTP/1.1`
        
- Une **Status-Line** pour une réponse :
    
    - format : `HTTP-Version SP Status-Code SP Reason-Phrase CRLF`
        
    - exemple : `HTTP/1.1 200 OK`
        

## 4.3 — En-têtes HTTP (Header Fields)

Les en-têtes sont une collection de paires nom/valeur, suivies de `CRLF` (retour chariot + saut de ligne).

Chaque en-tête a cette forme :

Nom: valeur

Exemple :  
Content-Type: text/html  
Content-Length: 342

Les en-têtes permettent de :

- décrire les capacités du client (`Accept`, `User-Agent`)
    
- donner des informations sur la ressource (`Content-Type`, `Last-Modified`)
    
- gérer la communication (`Connection`, `Host`, `Transfer-Encoding`)
    

## 4.4 — Corps du message (Message Body)

Le corps contient les **données effectives** transférées.

Il est facultatif :

- Présent dans les réponses à une requête `GET`, `POST`, etc.
    
- Peut être vide dans les réponses avec code `204 No Content`, `304 Not Modified` ou dans les requêtes `HEAD`.
    

Le corps peut être :

- **binaire** ou **texte**
    
- encodé (`gzip`, `chunked`, etc.)
    
- de taille connue (`Content-Length`) ou inconnue (avec `Transfer-Encoding: chunked`)
    

## 4.5 — Détection de la longueur du corps

Le client doit déterminer la longueur du corps à l’aide des en-têtes suivants :

- **Content-Length** : indique la taille exacte du corps, en octets
    
- **Transfer-Encoding: chunked** : si présent, la longueur n’est pas donnée d’avance. Le corps est envoyé en plusieurs segments.
    

S’il n’y a ni `Content-Length` ni `Transfer-Encoding`, alors la fin du corps est déterminée par la **fermeture de la connexion**.

## 4.6 — Connexion persistance

Par défaut en HTTP/1.1, les connexions sont **persistantes** (non fermées immédiatement après une requête/réponse), sauf si l’en-tête `Connection: close` est envoyé.

Cela permet d’envoyer plusieurs requêtes sur la même connexion TCP sans l’ouvrir et la fermer à chaque fois.

---

# RFC 2616 — Section 5 : Request

## 5.1 — Ligne de requête (Request-Line)

La ligne de requête est la première ligne d’un message HTTP émis par un client.

Elle a la forme suivante :

**Method SP Request-URI SP HTTP-Version CRLF**

Exemple :  
GET /index.html HTTP/1.1

- **Method** : la méthode HTTP (GET, POST, etc.)
    
- **Request-URI** : l’identifiant de la ressource demandée
    
- **HTTP-Version** : la version du protocole utilisée
    

Cette ligne est suivie des en-têtes, d’une ligne vide, puis éventuellement d’un corps.


## 5.1.1 — Méthodes HTTP

Les méthodes définissent l’action à effectuer sur la ressource.

Les méthodes standard de HTTP/1.1 sont :

- **GET** : demande une représentation de la ressource. Ne doit pas avoir d'effet secondaire.
    
- **HEAD** : identique à GET, mais sans le corps de la réponse.
    
- **POST** : soumet des données à traiter (formulaire, upload…).
    
- **PUT** : remplace ou crée une ressource à l’URI spécifiée.
    
- **DELETE** : supprime la ressource ciblée.
    
- **OPTIONS** : interroge le serveur sur les capacités disponibles.
    
- **TRACE** : retourne la requête telle que reçue par le serveur (utilisé pour le débogage).
    
- **CONNECT** : établit un tunnel TCP, typiquement utilisé pour le HTTPS via proxy.
    

> Remarque : Les méthodes doivent être reconnues par le serveur. Si une méthode n’est pas comprise, le serveur doit renvoyer un code 501 (Not Implemented).


## 5.1.2 — URI de requête (Request-URI)

L’URI de la requête identifie la ressource ciblée.

Il peut avoir l’une des formes suivantes :

- **Absolute URI** : utilisé principalement par les proxies (`http://example.com/index.html`)
    
- **Absolute path** : la forme la plus courante (`/index.html`)
    
- **Authority** : utilisé avec la méthode `CONNECT` (`www.example.com:443`)
    
- **"*”** : signifie “toutes les ressources” ; utilisé avec la méthode `OPTIONS`
    

> Remarque : Le serveur utilise l’en-tête `Host` en HTTP/1.1 pour déterminer quel hôte est concerné par la requête.


## 5.2 — En-têtes de requête (Request Headers)

Les en-têtes de requête sont utilisés pour :

- transmettre des **informations sur le client** (ex : `User-Agent`, `Referer`)
    
- **définir les préférences du client** (ex : `Accept`, `Accept-Language`)
    
- **contrôler la requête** elle-même (`Expect`, `Max-Forwards`, etc.)
    

Les types d’en-têtes peuvent être regroupés en trois catégories :

1. **En-têtes généraux** : valables pour la requête et la réponse (ex : `Date`, `Connection`)
    
2. **En-têtes spécifiques à la requête** : influencent le traitement (ex : `Accept`, `Host`)
    
3. **En-têtes d’entité** : décrivent le corps du message (ex : `Content-Type`, `Content-Length`)
    

## 5.3 — Host Header (obligatoire en HTTP/1.1)

Le champ `Host` est **obligatoire** dans toutes les requêtes HTTP/1.1.

Il permet de spécifier le **nom de domaine** ciblé par la requête, ce qui est indispensable pour l’hébergement virtuel.

Exemple :  
Host: [www.example.com](http://www.example.com/)

Si l’en-tête `Host` est absent, le serveur doit répondre avec un code **400 Bad Request**.


---

# RFC 2616 — Section 6 : Response

# 6.1 — Ligne de statut (Status-Line)

La ligne de statut est la première ligne d’une réponse HTTP envoyée par le serveur.

Format :  
**HTTP-Version SP Status-Code SP Reason-Phrase CRLF**

Exemple :  
HTTP/1.1 200 OK

- **HTTP-Version** : version du protocole utilisée
    
- **Status-Code** : code numérique indiquant le résultat
    
- **Reason-Phrase** : texte lisible décrivant le statut
    

Le champ Reason-Phrase est fourni à titre indicatif, mais les clients doivent se fier uniquement au code numérique.

# 6.2 — Codes de statut (Status Codes)

Les codes de statut HTTP sont regroupés en 5 classes principales selon le premier chiffre :

- **1xx** (Information) : la requête a été reçue et continue à être traitée
    
- **2xx** (Succès) : la requête a été reçue, comprise et acceptée
    
- **3xx** (Redirection) : des actions supplémentaires sont nécessaires pour terminer la requête
    
- **4xx** (Erreur client) : la requête comporte une erreur du côté client
    
- **5xx** (Erreur serveur) : le serveur n’a pas pu traiter une requête valide
    

Chaque code est suivi d’un message explicatif (Reason-Phrase), comme "OK" pour 200 ou "Not Found" pour 404.

# 6.3 — En-têtes de réponse (Response Headers)

Les en-têtes de réponse permettent de transmettre des informations utiles sur :

- Le serveur (`Server`, `Date`)
    
- La ressource (`Content-Type`, `Content-Length`, `Last-Modified`)
    
- Le comportement de la connexion (`Connection`, `Keep-Alive`)
    
- Le cache (`Cache-Control`, `Expires`, `ETag`)
    

Les en-têtes de réponse, comme ceux de requête, sont divisés en :

- **En-têtes généraux** : communs à requête et réponse
    
- **En-têtes de réponse spécifiques** : propres au serveur et à la ressource
    
- **En-têtes d'entité** : décrivent le contenu de la réponse
    

# 6.4 — Corps de la réponse (Response Body)

Le corps contient les **données renvoyées au client**, généralement une représentation de la ressource demandée.

Il est présent dans la plupart des réponses, sauf :

- Réponses `1xx`, `204 No Content`, `304 Not Modified`
    
- Requêtes `HEAD`, qui ne doivent renvoyer que les en-têtes
    

Le corps est encodé et typé selon les en-têtes :

- `Content-Type` : type MIME (ex : `text/html`)
    
- `Content-Encoding` : compression éventuelle (ex : `gzip`)
    
- `Content-Length` ou `Transfer-Encoding` : indiquent la taille ou le mode de transmission


---

# RFC 2616 — Section 7 : Entity

# 7.1 — Qu’est-ce qu’une entité ?

Une **entité** dans HTTP correspond à **l’information transmise avec une requête ou une réponse**. Elle est composée de deux parties :

1. **En-têtes d’entité** (entity headers)
    
2. **Corps de l’entité** (entity body), c’est-à-dire les données proprement dites
    

Les entités sont présentes dans :

- les requêtes contenant des données (ex : POST, PUT)
    
- les réponses contenant du contenu (ex : GET, 200 OK)
    

# 7.2 — En-têtes d’entité (Entity Headers)

Ces en-têtes fournissent des **métadonnées** décrivant le contenu de l’entité.

En-têtes définis dans HTTP/1.1 :

- `Content-Type` : type MIME du contenu
    
- `Content-Encoding` : transformation appliquée au contenu
    
- `Content-Language` : langue utilisée
    
- `Content-Length` : taille en octets du corps
    
- `Content-Location` : URI de la représentation envoyée
    
- `Content-MD5` : empreinte du contenu
    
- `Last-Modified` : date de dernière modification de la ressource
    
- `Expires` : date après laquelle le contenu est considéré périmé
    
- `ETag` : identifiant unique de version du contenu
    

Ces en-têtes peuvent être utilisés pour :

- informer le client sur le format ou la validité du contenu
    
- aider à la mise en cache et à la négociation de contenu
    
- détecter les modifications entre versions successives d’une ressource
    

# 7.3 — Corps de l’entité (Entity Body)

Le corps de l’entité contient les **données réelles** à transmettre, comme :

- une page HTML
    
- un fichier image, JSON, XML, etc.
    
- un flux binaire encodé
    

Le corps peut être :

- **absent** (ex : requête GET sans payload)
    
- **présent et vide** (Content-Length: 0)
    
- **présent avec une taille connue ou encodée par blocs (`chunked`)**
    

Sa longueur est déterminée par :

- `Content-Length` (taille exacte)
    
- `Transfer-Encoding` (encodage progressif)
    

Le corps est optionnel mais doit être interprété selon les en-têtes d’entité fournis.

# 7.4 — Entité vs Ressource

Une entité est **une représentation** d’une ressource **à un instant donné**.  
Elle n’est pas la ressource elle-même.

Par exemple :

- Une ressource `/image.jpg` peut être représentée par différentes entités (JPEG compressé, PNG, etc.)
    
- La ressource peut évoluer dans le temps, chaque version ayant une entité différente (`ETag`, `Last-Modified`)
    

---

# RFC 2616 — Section 8 : Connections

# 8.1 — Connexions persistantes

En HTTP/1.0, une nouvelle connexion TCP était ouverte pour chaque requête/réponse.  
En HTTP/1.1, les **connexions persistantes** sont introduites par défaut, sauf indication contraire.

Cela signifie qu’une même connexion TCP peut être réutilisée pour **plusieurs requêtes et réponses**, ce qui améliore considérablement les performances réseau.

## Avantages :

- Moins de surcharge liée à l’établissement de connexions TCP
    
- Moins de latence globale
    
- Réduction du nombre de ports utilisés simultanément
    

## Mécanisme :

- Par défaut, les connexions HTTP/1.1 sont **"keep-alive"**.
    
- Pour fermer explicitement la connexion, un en-tête `Connection: close` doit être envoyé.
    
- Le client peut envoyer plusieurs requêtes consécutives (pipelining), bien que ce soit rarement utilisé.
    

# 8.1.1 — Réutilisation d'une connexion

Le serveur **peut** garder une connexion ouverte après avoir envoyé une réponse, si :

- Il est sûr que la requête a été complètement reçue
    
- Aucune erreur de parsing n’a eu lieu
    

Sinon, il **doit** fermer la connexion pour éviter les incohérences.

# 8.1.2 — En-tête `Connection`

L'en-tête `Connection` permet de spécifier les options spécifiques à une connexion.

Exemples :

- `Connection: close` → demande de fermer la connexion après la réponse
    
- `Connection: keep-alive` → utilisée en HTTP/1.0 pour activer la persistance
    

En HTTP/1.1, la persistance est **automatique**, donc `Connection: keep-alive` est implicite.

# 8.2 — Pipelining de requêtes

Le **pipelining** permet à un client d’envoyer plusieurs requêtes **sans attendre les réponses** correspondantes.

Exemple :

- Le client envoie 3 requêtes d’un coup (sans attendre les réponses)
    
- Le serveur doit **répondre dans le même ordre**
    

### Contraintes :

- Toutes les requêtes doivent utiliser la méthode `safe` (`GET`, `HEAD`, etc.)
    
- Les réponses doivent être retournées **dans l'ordre exact des requêtes**
    
- Tous les serveurs ne le gèrent pas bien, et les navigateurs modernes l'ont souvent désactivé par défaut
    

# 8.2.1 — Anticipation des corps de requête : Expect / 100-continue

Quand un client veut envoyer une grosse requête (ex : upload via `POST`), il peut d’abord demander au serveur s’il est prêt à la traiter.

Cela se fait avec :

```
Expect: 100-continue
```

Le serveur répond alors :

- `100 Continue` → OK, le client peut envoyer le corps
    
- Un autre code d’erreur → inutile d’envoyer le corps
    

Ce mécanisme évite d’envoyer un corps volumineux inutilement, si le serveur doit refuser la requête.


---

# RFC 2616 — Section 9 : Method Definitions

Cette section décrit en détail les méthodes HTTP standard définies par le protocole.  
Chaque méthode spécifie une **action sémantique** à effectuer sur une ressource.

# 9.1 — Sécurité des méthodes

Certaines méthodes sont dites :

- **Safe** : elles n'ont **pas d'effet secondaire** sur le serveur. Elles servent à **récupérer de l'information** sans modifier d’état. Exemple : `GET`, `HEAD`.
    
- **Idempotentes** : une requête répétée **n’aura pas d’effet supplémentaire**. Exemple : `PUT`, `DELETE`, `GET`. Cela ne veut pas dire qu’elles sont sûres, mais qu’elles ne produisent pas d’effet cumulé.
    

# 9.2 — GET

- Récupère une représentation de la ressource.
    
- Ne doit pas avoir d’effets secondaires (safe).
    
- Les données peuvent être mises en cache.
    
- Aucune entité ne doit être incluse dans la requête.
    

# 9.3 — HEAD

- Identique à `GET`, mais sans le corps de la réponse.
    
- Sert souvent à vérifier la présence ou la mise à jour d’une ressource.
    

# 9.4 — POST

- Envoie des **données au serveur** pour traitement (ex : formulaire, fichier).
    
- Les données sont incluses dans le corps de la requête.
    
- Le résultat peut être la création d’une ressource, une mise à jour, ou autre.
    

Exemples d’usage :

- Soumission de formulaire
    
- Création de commentaire
    
- Déclenchement d'une action côté serveur
    

# 9.5 — PUT

- Remplace ou crée une ressource **à l’URI spécifiée**.
    
- Idempotente : plusieurs requêtes identiques produisent le même résultat.
    
- Le client envoie **la représentation complète** de la ressource.
    

Exemple :  
`PUT /fichier.txt` avec un corps contenant le fichier à stocker.

# 9.6 — DELETE

- Supprime la ressource à l’URI spécifié.
    
- Idempotente.
    
- Le serveur **n’est pas obligé** de supprimer réellement la ressource, mais il doit renvoyer un code cohérent (`200`, `202`, `204` ou erreur).
    

# 9.7 — TRACE

- Sert à **tester le chemin** qu'une requête parcourt jusqu'au serveur.
    
- Le serveur renvoie dans le corps de la réponse **la requête reçue**, telle quelle.
    
- Utilisé pour le **débogage** ou la **transparence des proxies**.
    

# 9.8 — OPTIONS

- Renvoie les **méthodes supportées** par le serveur ou la ressource.
    
- Ne modifie pas l’état du serveur.
    
- Peut s’appliquer à une ressource spécifique ou à `"*"` (pour interroger le serveur globalement).
    

Exemple :  
`OPTIONS * HTTP/1.1`

# 9.9 — CONNECT

- Utilisée pour **établir un tunnel TCP** à travers un proxy HTTP.
    
- Principalement utilisée pour **le trafic chiffré TLS/SSL** (ex : HTTPS).
    
- Exemple : `CONNECT www.example.com:443 HTTP/1.1`
    
Voici la **section 10 — Status Code Definitions** du RFC 2616, rédigée en **Markdown simple**, prête à être ajoutée à ton fichier `.md`.


---

# RFC 2616 — Section 10 : Status Code Definitions

Les **codes de statut HTTP** indiquent le résultat du traitement d'une requête.  
Chaque code est un entier à trois chiffres, souvent accompagné d’un texte descriptif (**reason-phrase**).

Les codes sont regroupés en **5 classes** selon leur premier chiffre :

- **1xx — Information** : traitement en cours
    
- **2xx — Succès** : la requête a réussi
    
- **3xx — Redirection** : action supplémentaire requise (souvent suivre une nouvelle URL)
    
- **4xx — Erreur client** : problème côté client
    
- **5xx — Erreur serveur** : le serveur n’a pas réussi à exécuter une requête valide
    

# 10.1 — 1xx : Informational

Réponses intermédiaires, rarement utilisées directement par les clients.

- **100 Continue** : le client peut continuer à envoyer le corps de la requête.
    
- **101 Switching Protocols** : le serveur accepte de changer de protocole (ex : passage à WebSocket).
    

# 10.2 — 2xx : Success

La requête a été reçue, comprise et acceptée.

- **200 OK** : réponse réussie, corps de réponse présent.
    
- **201 Created** : ressource créée, généralement après un `PUT` ou `POST`.
    
- **202 Accepted** : requête acceptée pour traitement ultérieur.
    
- **203 Non-Authoritative Information** : la réponse est valide mais provient d’une source secondaire.
    
- **204 No Content** : requête réussie, mais sans corps de réponse.
    
- **205 Reset Content** : le client doit réinitialiser l’état du document (ex : formulaire).
    
- **206 Partial Content** : envoi partiel d’un document (ex : téléchargement par morceaux).
    

# 10.3 — 3xx : Redirection

Le client doit effectuer une action supplémentaire pour terminer la requête.

- **300 Multiple Choices** : plusieurs représentations possibles.
    
- **301 Moved Permanently** : ressource déplacée de façon permanente.
    
- **302 Found** : ressource temporairement déplacée.
    
- **303 See Other** : le client doit effectuer une requête GET sur une autre URI.
    
- **304 Not Modified** : la ressource n’a pas changé depuis la dernière requête.
    
- **305 Use Proxy** : la ressource doit être accédée via un proxy.
    
- **307 Temporary Redirect** : redirection temporaire sans changement de méthode.
    

# 10.4 — 4xx : Client Error

Erreur liée à la requête du client.

- **400 Bad Request** : requête mal formée.
    
- **401 Unauthorized** : authentification requise.
    
- **402 Payment Required** : réservé à un usage futur.
    
- **403 Forbidden** : accès refusé, même avec authentification.
    
- **404 Not Found** : ressource non trouvée.
    
- **405 Method Not Allowed** : méthode non autorisée pour cette ressource.
    
- **406 Not Acceptable** : aucune version acceptable de la ressource trouvée.
    
- **407 Proxy Authentication Required** : authentification requise par un proxy.
    
- **408 Request Timeout** : le client a mis trop de temps à envoyer la requête.
    
- **409 Conflict** : conflit avec l’état actuel de la ressource.
    
- **410 Gone** : la ressource n’est plus disponible définitivement.
    
- **411 Length Required** : le champ `Content-Length` est requis.
    
- **412 Precondition Failed** : une condition dans la requête a échoué.
    
- **413 Request Entity Too Large** : le corps de la requête est trop volumineux.
    
- **414 Request-URI Too Long** : l’URI de la requête est trop longue.
    
- **415 Unsupported Media Type** : type de contenu non supporté.
    
- **416 Requested Range Not Satisfiable** : plage de données demandée invalide.
    
- **417 Expectation Failed** : une attente spécifiée dans `Expect` n’a pas pu être satisfaite.
    

# 10.5 — 5xx : Server Error

Erreur du serveur pendant le traitement de la requête.

- **500 Internal Server Error** : erreur générique côté serveur.
    
- **501 Not Implemented** : méthode non prise en charge par le serveur.
    
- **502 Bad Gateway** : réponse invalide reçue d’un serveur en amont.
    
- **503 Service Unavailable** : le serveur est temporairement indisponible (surcharge, maintenance…).
    
- **504 Gateway Timeout** : délai dépassé pour une réponse d’un serveur en amont.
    
- **505 HTTP Version Not Supported** : version du protocole non supportée.


---

# RFC 2616 — Section 11 : Access Authentication

HTTP/1.1 inclut un mécanisme standardisé d’**authentification** d'accès pour protéger les ressources.

L’authentification HTTP repose sur deux composants principaux :

- Le **client**, qui fournit des identifiants
    
- Le **serveur**, qui exige une authentification avant de délivrer la ressource
    

# 11.1 — Généralités

L’authentification se fait grâce à des **en-têtes spécifiques** échangés entre client et serveur.

- Le serveur envoie un **code 401 Unauthorized** avec l’en-tête `WWW-Authenticate`
    
- Le client répond avec l’en-tête `Authorization`, contenant les identifiants
    

Ce mécanisme est **stateless** : chaque requête nécessitant une authentification doit inclure les informations d'identification.

# 11.2 — WWW-Authenticate

Cet en-tête est envoyé par le serveur pour indiquer **quelle méthode d’authentification** il attend.

Format général :  
WWW-Authenticate: realm=""

Exemples :

- WWW-Authenticate: Basic realm="Espace sécurisé"
    
- WWW-Authenticate: Digest realm="Domaine sécurisé", ...
    

Le champ `realm` sert à **identifier la zone protégée** pour laquelle l’authentification est requise.

# 11.3 — Authorization

C’est la réponse du client à une demande d’authentification.  
Elle contient les identifiants dans un format dépendant de la méthode choisie (`Basic`, `Digest`, etc.)

Exemple :  
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==

> ⚠️ Le schéma Basic encode simplement les identifiants en Base64, sans chiffrement — ce n’est **pas sécurisé** sans HTTPS.

# 11.4 — Proxy-Authenticate et Proxy-Authorization

Un **proxy** peut également exiger une authentification :

- `Proxy-Authenticate` : équivalent de `WWW-Authenticate`, mais pour un proxy
    
- `Proxy-Authorization` : équivalent de `Authorization`, mais envoyé au proxy
    

Ce mécanisme est utilisé pour **l’accès contrôlé à des passerelles ou réseaux protégés**.


---

# RFC 2616 — Section 12 : Content Negotiation

La **négociation de contenu** permet à un serveur HTTP de proposer la **meilleure représentation d’une ressource** en fonction des préférences du client.

Une même ressource peut exister sous plusieurs formes :

- Différentes langues (français, anglais…)
    
- Différents formats (HTML, JSON, XML…)
    
- Différents encodages (compressé ou non…)
    

Le client peut indiquer ses préférences via plusieurs en-têtes, et le serveur choisit la version la plus appropriée.

# 12.1 — Dimensions de la négociation

Trois principales dimensions sont utilisées :

- **Type de média** (`Accept`) : indique les formats préférés (ex: `text/html`, `application/json`)
    
- **Langue** (`Accept-Language`) : indique les langues préférées (ex: `fr`, `en-US`)
    
- **Encodage** (`Accept-Encoding`) : indique les codages de compression acceptés (ex: `gzip`, `deflate`)
    
- **Jeu de caractères** (`Accept-Charset`) : indique les encodages de caractères préférés (ex: `UTF-8`, `ISO-8859-1`)
    

Chaque champ peut inclure un **paramètre de qualité `q`** (entre 0 et 1) pour indiquer le niveau de préférence.

Exemple :  
Accept-Language: fr, en;q=0.8, de;q=0.5

# 12.2 — Mécanismes de négociation

Deux approches sont possibles :

## Négociation côté serveur (server-driven)

- Le serveur choisit la représentation à renvoyer en fonction des en-têtes `Accept-*`
    
- Avantage : transparent pour le client
    
- Inconvénient : le serveur peut se tromper (ambiguïté)
    

## Négociation côté client (agent-driven)

- Le serveur renvoie une réponse listant les versions possibles (ex: `300 Multiple Choices`)
    
- Le **client choisit** ensuite la version souhaitée
    
- Moins utilisé en pratique, mais plus explicite
    

# 12.3 — Transparence de la négociation

Le protocole HTTP permet la négociation **sans changer l’URI** de la ressource.  
Autrement dit, plusieurs représentations peuvent être servies sous la **même URL**, en fonction du contexte de la requête.

Exemple :  
`GET /manuel` peut renvoyer :

- `manuel.html` si `Accept: text/html`
    
- `manuel.pdf` si `Accept: application/pdf`
    

# 12.4 — Caching et négociation

La négociation peut rendre la mise en cache plus complexe.

Pour cela, les caches HTTP doivent tenir compte des en-têtes de variation via le champ :

`Vary: Accept, Accept-Language`

Cela indique au cache que le contenu dépend de ces champs, et qu’il ne faut pas servir la même version à tout le monde.

---

# RFC 2616 — Section 13 : Caching in HTTP

Le **cache HTTP** permet de stocker localement des réponses pour éviter des requêtes répétées identiques.  
Il vise à **améliorer les performances**, **réduire la charge réseau** et **accélérer l'affichage** pour l'utilisateur.

Le cache peut être :

- côté **client** (navigateur)
    
- côté **proxy**
    
- ou intégré dans un **serveur intermédiaire**
    

# 13.1 — Buts du cache

- Réduire la latence
    
- Réduire la charge sur les serveurs
    
- Réduire la consommation de bande passante
    
- Améliorer la réactivité perçue par l'utilisateur
    

Mais il ne doit **pas compromettre la cohérence** des données. HTTP définit donc des règles strictes pour déterminer quand une réponse est cacheable.

# 13.2 — Cacheabilité des réponses

Une réponse est **cacheable** si :

- Elle est associée à un code de statut cacheable (`200`, `203`, `206`, `300`, `301`, `410`)
    
- Elle ne contient pas d’instructions `Cache-Control` ou `Pragma` qui l’interdisent
    
- Elle contient des en-têtes permettant la validation ou l’expiration (`ETag`, `Last-Modified`, `Expires`)
    

Certaines réponses (comme `404`, `500`) peuvent être mises en cache **dans des cas particuliers**.

# 13.3 — Validation du cache

Avant d’utiliser une réponse stockée, le cache peut la **valider** auprès du serveur avec des en-têtes conditionnels :

- `If-Modified-Since`
    
- `If-None-Match` (avec `ETag`)
    

Le serveur peut alors répondre avec :

- `304 Not Modified` : le contenu est encore valide
    
- Une nouvelle version mise à jour
    

# 13.4 — Contrôle d'expiration

Pour savoir quand une réponse devient obsolète, on utilise :

- `Expires` : date/heure précise après laquelle la réponse est considérée périmée
    
- `Cache-Control: max-age=N` : durée (en secondes) pendant laquelle la réponse est fraîche
    

# 13.5 — Cache-Control

C’est l’en-tête central du système de cache HTTP/1.1. Il permet de contrôler précisément le comportement du cache.

Exemples de directives :

- `no-cache` : doit valider la réponse avant de l’utiliser
    
- `no-store` : ne doit pas stocker la réponse du tout
    
- `public` : peut être stockée par tout cache
    
- `private` : seulement pour le cache du client
    
- `max-age=N` : durée de validité (en secondes)
    
- `must-revalidate` : doit valider après expiration
    
- `proxy-revalidate` : idem, mais pour les proxies
    

# 13.6 — Requêtes non-cacheables

Les requêtes contenant :

- `Authorization`
    
- certaines méthodes (comme `POST`, `PUT`, `DELETE`)
    

ne sont généralement **pas mises en cache**, sauf si des directives explicites comme `Cache-Control: public` sont présentes.

# 13.7 — Invalidation du cache

Une entrée de cache doit être invalidée si :

- La méthode est autre que `GET` ou `HEAD` (ex : `PUT`, `DELETE`)
    
- Une nouvelle réponse a été reçue avec les mêmes URI et des champs de validation différents
    

# 13.8 — Caches partagés vs privés

- **Caches partagés** : utilisés par plusieurs utilisateurs (ex : proxy). Doivent respecter strictement les directives.
    
- **Caches privés** : spécifiques à un utilisateur (navigateur). Peuvent être plus souples, mais doivent respecter les en-têtes comme `private`.
    

# 13.9 — Champs Vary

L'en-tête `Vary` indique **quels champs d’en-tête influencent** la réponse servie.

Exemple :  
Vary: Accept-Encoding

Cela signifie que le cache doit stocker des versions distinctes selon la valeur de `Accept-Encoding`.


---

# RFC 2616 — Section 14 : Header Field Definitions

Cette section définit **tous les champs d’en-tête** standards du protocole HTTP/1.1, leur syntaxe et leur signification.

Chaque champ d’en-tête appartient à l’une des catégories suivantes :

- **En-têtes généraux** : utilisés aussi bien dans les requêtes que dans les réponses
    
- **En-têtes de requête** : spécifiques au client
    
- **En-têtes de réponse** : spécifiques au serveur
    
- **En-têtes d’entité** : décrivent le corps du message
    

# 14.1 — Accept

Indique les types MIME que le client peut accepter.

Exemple :  
Accept: text/html, application/json;q=0.9, _/_;q=0.8

# 14.2 — Accept-Charset

Indique les jeux de caractères acceptés par le client.

Exemple :  
Accept-Charset: utf-8, iso-8859-1;q=0.5

# 14.3 — Accept-Encoding

Liste les codages de contenu (compressions) acceptés.

Exemple :  
Accept-Encoding: gzip, deflate

# 14.4 — Accept-Language

Spécifie les langues acceptées.

Exemple :  
Accept-Language: fr, en;q=0.8

# 14.5 — Accept-Ranges

Utilisé par le serveur pour indiquer qu’il accepte les requêtes partielles (`Range`).

Exemple :  
Accept-Ranges: bytes

# 14.6 — Age

Temps écoulé depuis la génération de la réponse, en secondes (utilisé par les caches).

# 14.7 — Allow

Liste des méthodes autorisées pour une ressource.

Exemple :  
Allow: GET, POST, OPTIONS

# 14.8 — Authorization

Contient les identifiants envoyés par le client pour accéder à une ressource protégée.

# 14.9 — Cache-Control

Contrôle le comportement du cache (voir section 13).

# 14.10 — Connection

Gère les options spécifiques à la connexion (ex: `close`, `keep-alive`).

# 14.11 — Content-Encoding

Spécifie un encodage (ex: compression) appliqué au corps.

# 14.12 — Content-Language

Indique la langue du contenu de la réponse.

# 14.13 — Content-Length

Donne la taille (en octets) du corps de l’entité.

# 14.14 — Content-Location

URI alternative qui identifie la ressource réelle fournie.

# 14.15 — Content-MD5

Hash MD5 du corps, utilisé pour la vérification d’intégrité.

# 14.16 — Content-Range

Utilisé pour envoyer des **fragments** de ressource (ex : téléchargement partiel).

# 14.17 — Content-Type

Type MIME du corps (ex: `text/html`, `image/jpeg`).

# 14.18 — Date

Date et heure de génération du message (en GMT).

# 14.19 — ETag

Identifiant de version d’une ressource, utilisé pour la validation.

# 14.20 — Expect

Utilisé par le client pour indiquer une condition préalable (ex: `100-continue`).

# 14.21 — Expires

Date à partir de laquelle la réponse est périmée.

# 14.22 — From

Adresse email de l’utilisateur faisant la requête.

# 14.23 — Host

Nom de domaine et port de destination (obligatoire en HTTP/1.1).

# 14.24 — If-Match / 14.25 — If-Modified-Since / 14.26 — If-None-Match / 14.27 — If-Range / 14.28 — If-Unmodified-Since

Famille d’en-têtes utilisés pour les **requêtes conditionnelles**.  
Ils permettent d’économiser de la bande passante et d’assurer la cohérence des mises à jour.

# 14.29 — Last-Modified

Date de dernière modification de la ressource.

# 14.30 — Location

Indique une nouvelle URI pour la redirection.

# 14.31 — Max-Forwards

Utilisé avec TRACE et OPTIONS pour limiter le nombre de sauts proxy/gateway.

# 14.32 — Pragma

Directive générale pour le cache (ex: `Pragma: no-cache`, hérité de HTTP/1.0).

# 14.33 — Proxy-Authenticate / 14.34 — Proxy-Authorization

Mécanisme d’authentification entre client et proxy.

# 14.35 — Range

Permet de demander une **portion** de la ressource (ex: `bytes=500-999`).

# 14.36 — Referer

URI de la ressource ayant initié la requête (typo volontaire dans le RFC : "Referer" au lieu de "Referrer").

# 14.37 — Retry-After

Spécifie combien de temps attendre avant de réessayer (utilisé avec `503 Service Unavailable`).

# 14.38 — Server

Identifie le logiciel serveur HTTP (ex: `Apache/2.4`).

# 14.39 — TE

Spécifie les encodages de transfert acceptés (`chunked`, `gzip`, etc.).

# 14.40 — Trailer

Indique les champs d’en-tête présents dans la bande-annonce (`trailer`) d’une réponse chunked.

# 14.41 — Transfer-Encoding

Indique l’encodage utilisé pour transmettre le corps (`chunked`, etc.)

# 14.42 — Upgrade

Permet de demander un changement de protocole (ex : vers HTTP/2, WebSocket).

# 14.43 — User-Agent

Chaîne d’identification du client HTTP (ex: navigateur, bot…).

# 14.44 — Vary

Indique quels en-têtes influencent la représentation de la ressource (ex: `Vary: Accept-Language`).

# 14.45 — Via

Indique le cheminement d'une requête à travers des proxies.

# 14.46 — Warning

Transmet des **informations de diagnostic** (ex : contenu expiré mais encore servi).

# 14.47 — WWW-Authenticate

En-tête envoyé par le serveur pour demander une authentification.

---

# RFC 2616 — Section 15 : Security Considerations

Cette section décrit les **principaux risques de sécurité** liés au protocole HTTP/1.1 et fournit des recommandations pour les atténuer.

HTTP étant un protocole de **texte en clair**, il n’intègre **aucun mécanisme natif de chiffrement ou de confidentialité**.  
Les aspects de sécurité dépendent donc fortement de la **conception des applications**, de l’**infrastructure réseau** et de l’utilisation de protocoles complémentaires comme **TLS (HTTPS)**.

# 15.1 — Confidentialité

- Par défaut, HTTP **ne chiffre aucune donnée** (en-têtes, URI, corps).
    
- Les informations sensibles (mots de passe, cookies, sessions) peuvent être interceptées par un attaquant si HTTP est utilisé sans chiffrement.
    
- Utiliser **HTTPS (HTTP over TLS)** est fortement recommandé pour toutes les communications sensibles.
    

# 15.2 — Authentification

- Le mécanisme d’authentification HTTP de base (`Basic`) **transmet les identifiants en Base64**, ce qui n’est **pas sécurisé** sans HTTPS.
    
- Les implémentations doivent :
    
    - Toujours **protéger les échanges d’authentification avec TLS**
        
    - Éviter de stocker les identifiants dans des URI ou des cookies non sécurisés
        

# 15.3 — Spoofing et falsification

- Les **en-têtes HTTP** peuvent être falsifiés, notamment `Referer`, `User-Agent`, `Host`, etc.
    
- Il ne faut **pas faire confiance aveuglément** à ces champs côté serveur.
    
- Les applications doivent valider et contrôler explicitement les données critiques.
    

# 15.4 — Attaques par redirection

- Les codes `3xx` peuvent rediriger un client vers un **site malveillant**.
    
- Le client doit vérifier si la redirection est autorisée ou attendue.
    
- Le serveur doit éviter de construire dynamiquement des redirections à partir de données utilisateur non filtrées.
    

# 15.5 — Injection d’en-têtes

- Certains serveurs vulnérables peuvent autoriser l’injection de **caractères de contrôle** (`\r\n`) dans les en-têtes.
    
- Cela peut conduire à des attaques de type **HTTP Response Splitting**.
    
- Les serveurs doivent **valider rigoureusement** tous les champs d’en-tête construits à partir d’entrées utilisateur.
    

# 15.6 — Requêtes inter-sites (Cross-Site Request Forgery)

- HTTP n’a pas de mécanisme intégré contre les attaques CSRF.
    
- Les applications web doivent mettre en place leurs propres protections (tokens anti-CSRF, vérification de l’origine...).
    

# 15.7 — Exposition d’informations sensibles

- Les en-têtes peuvent **fuiter des données sensibles** : chemins de fichiers, versions de logiciels (`Server`, `User-Agent`, etc.).
    
- Il est recommandé de **limiter les informations exposées** dans les en-têtes automatiques.
    

# 15.8 — Cache et sécurité

- Un **cache partagé** peut accidentellement stocker une réponse contenant des **données privées**.
    
- L’en-tête `Cache-Control: private` doit être utilisé pour éviter le stockage dans des caches partagés.
    
- `no-store` empêche tout stockage, même local.
    

# 15.9 — Code exécutable

- HTTP est souvent utilisé pour transférer du contenu exécutable (JavaScript, ActiveX, Java...).
    
- Les navigateurs doivent appliquer des **politiques de sécurité strictes** :
    
    - Contrôle d’origine (Same-Origin Policy)
        
    - Filtrage du contenu actif
        
    - Limitation des permissions du contenu embarqué
        

---

# RFC 2616 — Section 16 : Acknowledgments

Cette section rend hommage aux personnes ayant contribué de manière significative à la rédaction, l’évolution et la relecture de la spécification HTTP/1.1.

Le développement de HTTP/1.1 a été possible grâce aux travaux initiaux sur HTTP/1.0 et à la collaboration active de nombreux chercheurs, ingénieurs, universitaires et membres de la communauté IETF.

## Principaux contributeurs cités

Les auteurs remercient notamment les personnes suivantes pour leur implication, leurs commentaires techniques ou leur relecture attentive :

- Josh Cohen
    
- Roy T. Fielding
    
- Paul Leach
    
- Larry Masinter
    
- Jeffrey Mogul
    
- Henrik Frystyk Nielsen
    
- Dave Kristol
    
- Jim Gettys
    
- Koen Holtman
    
- Shel Kaphan
    
- Phillip M. Hallam-Baker
    
- John Franks
    
- Ari Luotonen
    
- Daniel W. Connolly
    
- et beaucoup d'autres membres actifs du groupe de travail HTTP-WG
    

Le RFC reconnaît également l’apport fondamental du **World Wide Web Consortium (W3C)** et des implémenteurs de serveurs et navigateurs web, dont les retours concrets ont permis d’affiner le protocole.

## Mention spéciale

Un remerciement particulier est adressé à **Tim Berners-Lee**, inventeur du World Wide Web, pour avoir posé les bases sur lesquelles HTTP a été conçu.
Voici la **section 17 — References** du RFC 2616, rédigée en **Markdown simple**, pour que tu puisses l'ajouter directement à ton fichier `.md` :

---

# RFC 2616 — Section 17 : References

La section des références du RFC 2616 liste tous les documents et normes sur lesquels s’appuie la spécification HTTP/1.1.  
Elle est divisée en deux catégories :

## 17.1 — Normatives References (Références normatives)

Ce sont les documents **essentiels** pour comprendre ou implémenter HTTP/1.1.  
Ils définissent les éléments de base utilisés dans le RFC.

- **[RFC 822]** — Standard for the format of ARPA Internet text messages (structure des en-têtes, base du format texte)
    
- **[RFC 1123]** — Requirements for Internet Hosts – Application and Support (usage des dates, conformité)
    
- **[RFC 2045]** — MIME Part One: Format of Internet Message Bodies
    
- **[RFC 2046]** — MIME Part Two: Media Types (définition des types MIME)
    
- **[RFC 2145]** — Use and Interpretation of HTTP Version Numbers
    
- **[RFC 2119]** — Key words for use in RFCs to Indicate Requirement Levels (MUST, SHOULD, MAY, etc.)
    
- **[RFC 2183]** — Content-Disposition Header Field (gestion des fichiers joints)
    

## 17.2 — Informative References (Références informatives)

Ces documents ne sont **pas requis** pour implémenter HTTP/1.1, mais fournissent un **contexte utile** ou une perspective historique.

- **[RFC 1945]** — HTTP/1.0 (ancienne version du protocole)
    
- **[RFC 1864]** — The Content-MD5 Header Field (utilisation des hash MD5 dans les entités)
    
- **[RFC 2047]** — MIME Header Extensions for Non-ASCII Text
    
- **[RFC 2068]** — Première version du draft HTTP/1.1 (remplacée par le présent RFC)
    
- **[RFC 2617]** — HTTP Authentication: Basic and Digest Access Authentication
    

Ces références complètent la compréhension du protocole et montrent son évolution progressive dans l’écosystème Internet.
